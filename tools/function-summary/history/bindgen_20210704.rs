/* automatically generated by rust-bindgen 0.57.0 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _TIME_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _STDC_PREDEF_H: u32 = 1;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _UCHAR_H: u32 = 1;
pub const __mbstate_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _CTYPE_H: u32 = 1;
pub const _WCHAR_H: u32 = 1;
pub const __wint_t_defined: u32 = 1;
pub const _WINT_T: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const FILENAME_MAX: u32 = 4096;
pub const FOPEN_MAX: u32 = 16;
pub const _GETOPT_POSIX_H: u32 = 1;
pub const _GETOPT_CORE_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const _STDLIB_H: u32 = 1;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _STRING_H: u32 = 1;
pub const _NSIG: u32 = 33;
pub const __sig_atomic_t_defined: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const _XOPEN_LIM_H: u32 = 1;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const IOV_MAX: u32 = 1024;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _BYTESWAP_H: u32 = 1;
pub const _NETINET_IN_H: u32 = 1;
pub const _SYS_SOCKET_H: u32 = 1;
pub const __iovec_defined: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _SS_SIZE: u32 = 128;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const _ENDIAN_H: u32 = 1;
pub const NCKEY_ESC: u32 = 27;
pub const NCKEY_SPACE: u32 = 32;
pub const NCBOXLIGHT: &'static [u8; 19usize] =
    b"\xE2\x94\x8C\xE2\x94\x90\xE2\x94\x94\xE2\x94\x98\xE2\x94\x80\xE2\x94\x82\0";
pub const NCBOXHEAVY: &'static [u8; 19usize] =
    b"\xE2\x94\x8F\xE2\x94\x93\xE2\x94\x97\xE2\x94\x9B\xE2\x94\x81\xE2\x94\x83\0";
pub const NCBOXROUND: &'static [u8; 19usize] =
    b"\xE2\x95\xAD\xE2\x95\xAE\xE2\x95\xB0\xE2\x95\xAF\xE2\x94\x80\xE2\x94\x82\0";
pub const NCBOXDOUBLE: &'static [u8; 19usize] =
    b"\xE2\x95\x94\xE2\x95\x97\xE2\x95\x9A\xE2\x95\x9D\xE2\x95\x90\xE2\x95\x91\0";
pub const NCBOXASCII: &'static [u8; 7usize] = b"/\\\\/-|\0";
pub const NCBOXOUTER : & 'static [u8 ; 32usize] = b"\xF0\x9F\xAD\xBD\xF0\x9F\xAD\xBE\xF0\x9F\xAD\xBC\xF0\x9F\xAD\xBF\xE2\x96\x81\xF0\x9F\xAD\xB5\xF0\x9F\xAD\xB6\xF0\x9F\xAD\xB0\0" ;
pub const NCBOXLIGHTW: &'static [u8; 19usize] =
    b"\xE2\x94\x8C\xE2\x94\x90\xE2\x94\x94\xE2\x94\x98\xE2\x94\x80\xE2\x94\x82\0";
pub const NCBOXHEAVYW: &'static [u8; 19usize] =
    b"\xE2\x94\x8F\xE2\x94\x93\xE2\x94\x97\xE2\x94\x9B\xE2\x94\x81\xE2\x94\x83\0";
pub const NCBOXROUNDW: &'static [u8; 19usize] =
    b"\xE2\x95\xAD\xE2\x95\xAE\xE2\x95\xB0\xE2\x95\xAF\xE2\x94\x80\xE2\x94\x82\0";
pub const NCBOXDOUBLEW: &'static [u8; 19usize] =
    b"\xE2\x95\x94\xE2\x95\x97\xE2\x95\x9A\xE2\x95\x9D\xE2\x95\x90\xE2\x95\x91\0";
pub const NCBOXASCIIW: &'static [u8; 7usize] = b"/\\\\/-|\0";
pub const NCBOXOUTERW : & 'static [u8 ; 32usize] = b"\xF0\x9F\xAD\xBD\xF0\x9F\xAD\xBE\xF0\x9F\xAD\xBC\xF0\x9F\xAD\xBF\xE2\x96\x81\xF0\x9F\xAD\xB5\xF0\x9F\xAD\xB6\xF0\x9F\xAD\xB0\0" ;
pub const NCWHITESQUARES: &'static [u8; 13usize] =
    b"\xE2\x97\xB2\xE2\x97\xB1\xE2\x97\xB3\xE2\x97\xB0\0";
pub const NCWHITECIRCLES: &'static [u8; 13usize] =
    b"\xE2\x97\xB6\xE2\x97\xB5\xE2\x97\xB7\xE2\x97\xB4\0";
pub const NCANGLESBR : & 'static [u8 ; 45usize] = b"\xF0\x9F\xAD\x81\xF0\x9F\xAD\x82\xF0\x9F\xAD\x83\xF0\x9F\xAD\x84\xF0\x9F\xAD\x85\xF0\x9F\xAD\x86\xF0\x9F\xAD\x87\xF0\x9F\xAD\x88\xF0\x9F\xAD\x89\xF0\x9F\xAD\x8A\xF0\x9F\xAD\x8B\0" ;
pub const NCANGLESTR : & 'static [u8 ; 45usize] = b"\xF0\x9F\xAD\x92\xF0\x9F\xAD\x93\xF0\x9F\xAD\x94\xF0\x9F\xAD\x95\xF0\x9F\xAD\x96\xF0\x9F\xAD\xA7\xF0\x9F\xAD\xA2\xF0\x9F\xAD\xA3\xF0\x9F\xAD\xA4\xF0\x9F\xAD\xA5\xF0\x9F\xAD\xA6\0" ;
pub const NCANGLESBL : & 'static [u8 ; 45usize] = b"\xF0\x9F\xAD\x8C\xF0\x9F\xAD\x8D\xF0\x9F\xAD\x8E\xF0\x9F\xAD\x8F\xF0\x9F\xAD\x90\xF0\x9F\xAD\x91\xF0\x9F\xAC\xBC\xF0\x9F\xAC\xBD\xF0\x9F\xAC\xBE\xF0\x9F\xAC\xBF\xF0\x9F\xAD\x80\0" ;
pub const NCANGLESTL : & 'static [u8 ; 45usize] = b"\xF0\x9F\xAD\x9D\xF0\x9F\xAD\x9E\xF0\x9F\xAD\x9F\xF0\x9F\xAD\xA0\xF0\x9F\xAD\xA1\xF0\x9F\xAD\x9C\xF0\x9F\xAD\x97\xF0\x9F\xAD\x98\xF0\x9F\xAD\x99\xF0\x9F\xAD\x9A\xF0\x9F\xAD\x9B\0" ;
pub const NCEIGHTHSB : & 'static [u8 ; 25usize] = b"\xE2\x96\x81\xE2\x96\x82\xE2\x96\x83\xE2\x96\x84\xE2\x96\x85\xE2\x96\x86\xE2\x96\x87\xE2\x96\x88\0" ;
pub const NCEIGHTHST : & 'static [u8 ; 30usize] = b"\xE2\x96\x94\xF0\x9F\xAE\x82\xF0\x9F\xAE\x83\xE2\x96\x80\xF0\x9F\xAE\x84\xF0\x9F\xAE\x85\xF0\x9F\xAE\x86\xE2\x96\x88\0" ;
pub const NCEIGHTHSL : & 'static [u8 ; 25usize] = b"\xE2\x96\x8F\xE2\x96\x8E\xE2\x96\x8D\xE2\x96\x8C\xE2\x96\x8B\xE2\x96\x8A\xE2\x96\x89\xE2\x96\x88\0" ;
pub const NCEIGHTHSR : & 'static [u8 ; 30usize] = b"\xE2\x96\x95\xF0\x9F\xAE\x87\xF0\x9F\xAE\x88\xE2\x96\x90\xF0\x9F\xAE\x89\xF0\x9F\xAE\x8A\xF0\x9F\xAE\x8B\xE2\x96\x88\0" ;
pub const NCHALFBLOCKS: &'static [u8; 11usize] = b" \xE2\x96\x80\xE2\x96\x84\xE2\x96\x88\0";
pub const NCQUADBLOCKS : & 'static [u8 ; 47usize] = b" \xE2\x96\x98\xE2\x96\x9D\xE2\x96\x80\xE2\x96\x96\xE2\x96\x8C\xE2\x96\x9E\xE2\x96\x9B\xE2\x96\x97\xE2\x96\x9A\xE2\x96\x90\xE2\x96\x9C\xE2\x96\x84\xE2\x96\x99\xE2\x96\x9F\xE2\x96\x88\0" ;
pub const NCSEXBLOCKS : & 'static [u8 ; 247usize] = b" \xF0\x9F\xAC\x80\xF0\x9F\xAC\x81\xF0\x9F\xAC\x82\xF0\x9F\xAC\x83\xF0\x9F\xAC\x84\xF0\x9F\xAC\x85\xF0\x9F\xAC\x86\xF0\x9F\xAC\x87\xF0\x9F\xAC\x88\xF0\x9F\xAC\x8A\xF0\x9F\xAC\x8B\xF0\x9F\xAC\x8C\xF0\x9F\xAC\x8D\xF0\x9F\xAC\x8E\xF0\x9F\xAC\x8F\xF0\x9F\xAC\x90\xF0\x9F\xAC\x91\xF0\x9F\xAC\x92\xF0\x9F\xAC\x93\xE2\x96\x8C\xF0\x9F\xAC\x94\xF0\x9F\xAC\x95\xF0\x9F\xAC\x96\xF0\x9F\xAC\x97\xF0\x9F\xAC\x98\xF0\x9F\xAC\x99\xF0\x9F\xAC\x9A\xF0\x9F\xAC\x9B\xF0\x9F\xAC\x9C\xF0\x9F\xAC\x9D\xF0\x9F\xAC\x9E\xF0\x9F\xAC\x9F\xF0\x9F\xAC\xA0\xF0\x9F\xAC\xA1\xF0\x9F\xAC\xA2\xF0\x9F\xAC\xA3\xF0\x9F\xAC\xA4\xF0\x9F\xAC\xA5\xF0\x9F\xAC\xA6\xF0\x9F\xAC\xA7\xE2\x96\x90\xF0\x9F\xAC\xA8\xF0\x9F\xAC\xA9\xF0\x9F\xAC\xAA\xF0\x9F\xAC\xAB\xF0\x9F\xAC\xAC\xF0\x9F\xAC\xAD\xF0\x9F\xAC\xAE\xF0\x9F\xAC\xAF\xF0\x9F\xAC\xB0\xF0\x9F\xAC\xB1\xF0\x9F\xAC\xB2\xF0\x9F\xAC\xB3\xF0\x9F\xAC\xB4\xF0\x9F\xAC\xB5\xF0\x9F\xAC\xB6\xF0\x9F\xAC\xB7\xF0\x9F\xAC\xB8\xF0\x9F\xAC\xB9\xF0\x9F\xAC\xBA\xF0\x9F\xAC\xBB\xE2\x96\x88\0" ;
pub const NCBRAILLEEGCS : & 'static [u8 ; 769usize] = b"\xE2\xA0\x80\xE2\xA0\x81\xE2\xA0\x88\xE2\xA0\x89\xE2\xA0\x82\xE2\xA0\x83\xE2\xA0\x8A\xE2\xA0\x8B\xE2\xA0\x90\xE2\xA0\x91\xE2\xA0\x98\xE2\xA0\x99\xE2\xA0\x92\xE2\xA0\x93\xE2\xA0\x9A\xE2\xA0\x9B\xE2\xA0\x84\xE2\xA0\x85\xE2\xA0\x8C\xE2\xA0\x8D\xE2\xA0\x86\xE2\xA0\x87\xE2\xA0\x8E\xE2\xA0\x8F\xE2\xA0\x94\xE2\xA0\x95\xE2\xA0\x9C\xE2\xA0\x9D\xE2\xA0\x96\xE2\xA0\x97\xE2\xA0\x9E\xE2\xA0\x9F\xE2\xA0\xA0\xE2\xA0\xA1\xE2\xA0\xA8\xE2\xA0\xA9\xE2\xA0\xA2\xE2\xA0\xA3\xE2\xA0\xAA\xE2\xA0\xAB\xE2\xA0\xB0\xE2\xA0\xB1\xE2\xA0\xB8\xE2\xA0\xB9\xE2\xA0\xB2\xE2\xA0\xB3\xE2\xA0\xBA\xE2\xA0\xBB\xE2\xA0\xA4\xE2\xA0\xA5\xE2\xA0\xAC\xE2\xA0\xAD\xE2\xA0\xA6\xE2\xA0\xA7\xE2\xA0\xAE\xE2\xA0\xAF\xE2\xA0\xB4\xE2\xA0\xB5\xE2\xA0\xBC\xE2\xA0\xBD\xE2\xA0\xB6\xE2\xA0\xB7\xE2\xA0\xBE\xE2\xA0\xBF\xE2\xA1\x80\xE2\xA1\x81\xE2\xA1\x88\xE2\xA1\x89\xE2\xA1\x82\xE2\xA1\x83\xE2\xA1\x8A\xE2\xA1\x8B\xE2\xA1\x90\xE2\xA1\x91\xE2\xA1\x98\xE2\xA1\x99\xE2\xA1\x92\xE2\xA1\x93\xE2\xA1\x9A\xE2\xA1\x9B\xE2\xA1\x84\xE2\xA1\x85\xE2\xA1\x8C\xE2\xA1\x8D\xE2\xA1\x86\xE2\xA1\x87\xE2\xA1\x8E\xE2\xA1\x8F\xE2\xA1\x94\xE2\xA1\x95\xE2\xA1\x9C\xE2\xA1\x9D\xE2\xA1\x96\xE2\xA1\x97\xE2\xA1\x9E\xE2\xA1\x9F\xE2\xA1\xA0\xE2\xA1\xA1\xE2\xA1\xA8\xE2\xA1\xA9\xE2\xA1\xA2\xE2\xA1\xA3\xE2\xA1\xAA\xE2\xA1\xAB\xE2\xA1\xB0\xE2\xA1\xB1\xE2\xA1\xB8\xE2\xA1\xB9\xE2\xA1\xB2\xE2\xA1\xB3\xE2\xA1\xBA\xE2\xA1\xBB\xE2\xA1\xA4\xE2\xA1\xA5\xE2\xA1\xAC\xE2\xA1\xAD\xE2\xA1\xA6\xE2\xA1\xA7\xE2\xA1\xAE\xE2\xA1\xAF\xE2\xA1\xB4\xE2\xA1\xB5\xE2\xA1\xBC\xE2\xA1\xBD\xE2\xA1\xB6\xE2\xA1\xB7\xE2\xA1\xBE\xE2\xA1\xBF\xE2\xA2\x80\xE2\xA2\x81\xE2\xA2\x88\xE2\xA2\x89\xE2\xA2\x82\xE2\xA2\x83\xE2\xA2\x8A\xE2\xA2\x8B\xE2\xA2\x90\xE2\xA2\x91\xE2\xA2\x98\xE2\xA2\x99\xE2\xA2\x92\xE2\xA2\x93\xE2\xA2\x9A\xE2\xA2\x9B\xE2\xA2\x84\xE2\xA2\x85\xE2\xA2\x8C\xE2\xA2\x8D\xE2\xA2\x86\xE2\xA2\x87\xE2\xA2\x8E\xE2\xA2\x8F\xE2\xA2\x94\xE2\xA2\x95\xE2\xA2\x9C\xE2\xA2\x9D\xE2\xA2\x96\xE2\xA2\x97\xE2\xA2\x9E\xE2\xA2\x9F\xE2\xA2\xA0\xE2\xA2\xA1\xE2\xA2\xA8\xE2\xA2\xA9\xE2\xA2\xA2\xE2\xA2\xA3\xE2\xA2\xAA\xE2\xA2\xAB\xE2\xA2\xB0\xE2\xA2\xB1\xE2\xA2\xB8\xE2\xA2\xB9\xE2\xA2\xB2\xE2\xA2\xB3\xE2\xA2\xBA\xE2\xA2\xBB\xE2\xA2\xA4\xE2\xA2\xA5\xE2\xA2\xAC\xE2\xA2\xAD\xE2\xA2\xA6\xE2\xA2\xA7\xE2\xA2\xAE\xE2\xA2\xAF\xE2\xA2\xB4\xE2\xA2\xB5\xE2\xA2\xBC\xE2\xA2\xBD\xE2\xA2\xB6\xE2\xA2\xB7\xE2\xA2\xBE\xE2\xA2\xBF\xE2\xA3\x80\xE2\xA3\x81\xE2\xA3\x88\xE2\xA3\x89\xE2\xA3\x82\xE2\xA3\x83\xE2\xA3\x8A\xE2\xA3\x8B\xE2\xA3\x90\xE2\xA3\x91\xE2\xA3\x98\xE2\xA3\x99\xE2\xA3\x92\xE2\xA3\x93\xE2\xA3\x9A\xE2\xA3\x9B\xE2\xA3\x84\xE2\xA3\x85\xE2\xA3\x8C\xE2\xA3\x8D\xE2\xA3\x86\xE2\xA3\x87\xE2\xA3\x8E\xE2\xA3\x8F\xE2\xA3\x94\xE2\xA3\x95\xE2\xA3\x9C\xE2\xA3\x9D\xE2\xA3\x96\xE2\xA3\x97\xE2\xA3\x9E\xE2\xA3\x9F\xE2\xA3\xA0\xE2\xA3\xA1\xE2\xA3\xA8\xE2\xA3\xA9\xE2\xA3\xA2\xE2\xA3\xA3\xE2\xA3\xAA\xE2\xA3\xAB\xE2\xA3\xB0\xE2\xA3\xB1\xE2\xA3\xB8\xE2\xA3\xB9\xE2\xA3\xB2\xE2\xA3\xB3\xE2\xA3\xBA\xE2\xA3\xBB\xE2\xA3\xA4\xE2\xA3\xA5\xE2\xA3\xAC\xE2\xA3\xAD\xE2\xA3\xA6\xE2\xA3\xA7\xE2\xA3\xAE\xE2\xA3\xAF\xE2\xA3\xB4\xE2\xA3\xB5\xE2\xA3\xBC\xE2\xA3\xBD\xE2\xA3\xB6\xE2\xA3\xB7\xE2\xA3\xBE\xE2\xA3\xBF\0" ;
pub const NCALPHA_HIGHCONTRAST: u32 = 805306368;
pub const NCALPHA_TRANSPARENT: u32 = 536870912;
pub const NCALPHA_BLEND: u32 = 268435456;
pub const NCALPHA_OPAQUE: u32 = 0;
pub const CELL_BGDEFAULT_MASK: u32 = 1073741824;
pub const CELL_FGDEFAULT_MASK: u64 = 4611686018427387904;
pub const CELL_BG_RGB_MASK: u32 = 16777215;
pub const CELL_FG_RGB_MASK: u64 = 72057589742960640;
pub const CELL_BG_PALETTE: u32 = 134217728;
pub const NCPALETTESIZE: u32 = 256;
pub const CELL_FG_PALETTE: u64 = 576460752303423488;
pub const CELL_BG_ALPHA_MASK: u32 = 805306368;
pub const CELL_FG_ALPHA_MASK: u64 = 3458764513820540928;
pub const NCSTYLE_MASK: u32 = 65535;
pub const NCSTYLE_ITALIC: u32 = 32;
pub const NCSTYLE_UNDERLINE: u32 = 16;
pub const NCSTYLE_UNDERCURL: u32 = 8;
pub const NCSTYLE_BOLD: u32 = 4;
pub const NCSTYLE_STRUCK: u32 = 2;
pub const NCSTYLE_BLINK: u32 = 1;
pub const NCSTYLE_NONE: u32 = 0;
pub const NCOPTION_INHIBIT_SETLOCALE: u32 = 1;
pub const NCOPTION_NO_CLEAR_BITMAPS: u32 = 2;
pub const NCOPTION_NO_WINCH_SIGHANDLER: u32 = 4;
pub const NCOPTION_NO_QUIT_SIGHANDLERS: u32 = 8;
pub const NCOPTION_PRESERVE_CURSOR: u32 = 16;
pub const NCOPTION_SUPPRESS_BANNERS: u32 = 32;
pub const NCOPTION_NO_ALTERNATE_SCREEN: u32 = 64;
pub const NCOPTION_NO_FONT_CHANGES: u32 = 128;
pub const NCPLANE_OPTION_HORALIGNED: u32 = 1;
pub const NCPLANE_OPTION_VERALIGNED: u32 = 2;
pub const NCPLANE_OPTION_MARGINALIZED: u32 = 4;
pub const NCBOXMASK_TOP: u32 = 1;
pub const NCBOXMASK_RIGHT: u32 = 2;
pub const NCBOXMASK_BOTTOM: u32 = 4;
pub const NCBOXMASK_LEFT: u32 = 8;
pub const NCBOXGRAD_TOP: u32 = 16;
pub const NCBOXGRAD_RIGHT: u32 = 32;
pub const NCBOXGRAD_BOTTOM: u32 = 64;
pub const NCBOXGRAD_LEFT: u32 = 128;
pub const NCBOXCORNER_MASK: u32 = 768;
pub const NCBOXCORNER_SHIFT: u32 = 8;
pub const NCVISUAL_OPTION_NODEGRADE: u32 = 1;
pub const NCVISUAL_OPTION_BLEND: u32 = 2;
pub const NCVISUAL_OPTION_HORALIGNED: u32 = 4;
pub const NCVISUAL_OPTION_VERALIGNED: u32 = 8;
pub const NCVISUAL_OPTION_ADDALPHA: u32 = 16;
pub const NCVISUAL_OPTION_CHILDPLANE: u32 = 32;
pub const NCVISUAL_OPTION_NOINTERPOLATE: u32 = 64;
pub const NCREEL_OPTION_INFINITESCROLL: u32 = 1;
pub const NCREEL_OPTION_CIRCULAR: u32 = 2;
pub const PREFIXCOLUMNS: u32 = 7;
pub const IPREFIXCOLUMNS: u32 = 8;
pub const BPREFIXCOLUMNS: u32 = 9;
pub const PREFIXSTRLEN: u32 = 8;
pub const IPREFIXSTRLEN: u32 = 9;
pub const BPREFIXSTRLEN: u32 = 10;
pub const NCMENU_OPTION_BOTTOM: u32 = 1;
pub const NCMENU_OPTION_HIDING: u32 = 2;
pub const NCPROGBAR_OPTION_RETROGRADE: u32 = 1;
pub const NCTABBED_OPTION_BOTTOM: u32 = 1;
pub const NCPLOT_OPTION_LABELTICKSD: u32 = 1;
pub const NCPLOT_OPTION_EXPONENTIALD: u32 = 2;
pub const NCPLOT_OPTION_VERTICALI: u32 = 4;
pub const NCPLOT_OPTION_NODEGRADE: u32 = 8;
pub const NCPLOT_OPTION_DETECTMAXONLY: u32 = 16;
pub const NCPLOT_OPTION_PRINTSAMPLE: u32 = 32;
pub const NCREADER_OPTION_HORSCROLL: u32 = 1;
pub const NCREADER_OPTION_VERSCROLL: u32 = 2;
pub const NCREADER_OPTION_NOCMDKEYS: u32 = 4;
pub const NCREADER_OPTION_CURSOR: u32 = 8;
pub const CELL_ALPHA_HIGHCONTRAST: u32 = 805306368;
pub const CELL_ALPHA_TRANSPARENT: u32 = 536870912;
pub const CELL_ALPHA_BLEND: u32 = 268435456;
pub const CELL_ALPHA_OPAQUE: u32 = 0;
pub const NCSTYLE_PROTECT: u32 = 1;
pub const NCSTYLE_STANDOUT: u32 = 128;
pub const NCSTYLE_REVERSE: u32 = 32;
pub const NCSTYLE_INVIS: u32 = 2;
pub const NCSTYLE_DIM: u32 = 8;
pub const NCDIRECT_OPTION_INHIBIT_SETLOCALE: u32 = 1;
pub const NCDIRECT_OPTION_INHIBIT_CBREAK: u32 = 2;
pub const NCDIRECT_OPTION_NO_QUIT_SIGHANDLERS: u32 = 8;
pub const NCDIRECT_OPTION_VERBOSE: u32 = 16;
pub const NCDIRECT_OPTION_VERY_VERBOSE: u32 = 32;
pub type size_t = cty::c_ulong;
#[doc = " Convenience types."]
pub type __u_char = cty::c_uchar;
pub type __u_short = cty::c_ushort;
pub type __u_int = cty::c_uint;
pub type __u_long = cty::c_ulong;
#[doc = " Fixed-size types, underlying types depend on word size and compiler."]
pub type __int8_t = cty::c_schar;
pub type __uint8_t = cty::c_uchar;
pub type __int16_t = cty::c_short;
pub type __uint16_t = cty::c_ushort;
pub type __int32_t = cty::c_int;
pub type __uint32_t = cty::c_uint;
pub type __int64_t = cty::c_long;
pub type __uint64_t = cty::c_ulong;
#[doc = " Smallest types with at least a given width."]
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = cty::c_long;
pub type __u_quad_t = cty::c_ulong;
pub type __intmax_t = cty::c_long;
pub type __uintmax_t = cty::c_ulong;
pub type __dev_t = cty::c_ulong;
pub type __uid_t = cty::c_uint;
pub type __gid_t = cty::c_uint;
pub type __ino_t = cty::c_ulong;
pub type __ino64_t = cty::c_ulong;
pub type __mode_t = cty::c_uint;
pub type __nlink_t = cty::c_ulong;
pub type __off_t = cty::c_long;
pub type __off64_t = cty::c_long;
pub type __pid_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __fsid_t {
    pub __val: [cty::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = cty::c_long;
pub type __rlim_t = cty::c_ulong;
pub type __rlim64_t = cty::c_ulong;
pub type __id_t = cty::c_uint;
pub type __time_t = cty::c_long;
pub type __useconds_t = cty::c_uint;
pub type __suseconds_t = cty::c_long;
pub type __daddr_t = cty::c_int;
pub type __key_t = cty::c_int;
pub type __clockid_t = cty::c_int;
pub type __timer_t = *mut cty::c_void;
pub type __blksize_t = cty::c_long;
pub type __blkcnt_t = cty::c_long;
pub type __blkcnt64_t = cty::c_long;
pub type __fsblkcnt_t = cty::c_ulong;
pub type __fsblkcnt64_t = cty::c_ulong;
pub type __fsfilcnt_t = cty::c_ulong;
pub type __fsfilcnt64_t = cty::c_ulong;
pub type __fsword_t = cty::c_long;
pub type __ssize_t = cty::c_long;
pub type __syscall_slong_t = cty::c_long;
pub type __syscall_ulong_t = cty::c_ulong;
#[doc = " These few don't really vary by system, they always correspond"]
#[doc = "to one of the other defined types."]
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut cty::c_char;
pub type __intptr_t = cty::c_long;
pub type __socklen_t = cty::c_uint;
#[doc = " C99: An integer type that can be accessed as an atomic entity,"]
#[doc = "even in the presence of asynchronous interrupts."]
#[doc = "It is not currently necessary for this to be machine-specific."]
pub type __sig_atomic_t = cty::c_int;
#[doc = " Returned by `clock'."]
pub type clock_t = __clock_t;
#[doc = " Returned by `time'."]
pub type time_t = __time_t;
#[doc = " ISO C `broken-down time' structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct tm {
    #[doc = " Seconds.\t[0-60] (1 leap second)"]
    pub tm_sec: cty::c_int,
    #[doc = " Minutes.\t[0-59]"]
    pub tm_min: cty::c_int,
    #[doc = " Hours.\t[0-23]"]
    pub tm_hour: cty::c_int,
    #[doc = " Day.\t\t[1-31]"]
    pub tm_mday: cty::c_int,
    #[doc = " Month.\t[0-11]"]
    pub tm_mon: cty::c_int,
    #[doc = " Year\t- 1900."]
    pub tm_year: cty::c_int,
    #[doc = " Day of week.\t[0-6]"]
    pub tm_wday: cty::c_int,
    #[doc = " Days in year.[0-365]"]
    pub tm_yday: cty::c_int,
    #[doc = " DST.\t\t[-1/0/1]"]
    pub tm_isdst: cty::c_int,
    #[doc = " Seconds east of UTC."]
    pub __tm_gmtoff: cty::c_long,
    #[doc = " Timezone abbreviation."]
    pub __tm_zone: *const cty::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::core::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::core::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).__tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(__tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).__tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(__tm_zone)
        )
    );
}
impl Default for tm {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " POSIX.1b structure for a time value.  This is like a `struct timeval' but"]
#[doc = "has nanoseconds instead of microseconds."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct timespec {
    #[doc = " Seconds."]
    pub tv_sec: __time_t,
    #[doc = " Nanoseconds."]
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::core::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::core::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
extern "C" {
    pub static mut __tzname: [*mut cty::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: cty::c_int;
}
extern "C" {
    pub static mut __timezone: cty::c_long;
}
extern "C" {
    pub static mut tzname: [*mut cty::c_char; 2usize];
}
extern "C" {
    pub static mut daylight: cty::c_int;
}
extern "C" {
    pub static mut timezone: cty::c_long;
}
#[doc = " Conversion state information."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: cty::c_int,
    #[doc = " Value so far."]
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: cty::c_uint,
    pub __wchb: [cty::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
impl Default for __mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
impl Default for __mbstate_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type mbstate_t = __mbstate_t;
#[doc = " Define the 16-bit and 32-bit character types."]
pub type char16_t = __uint_least16_t;
pub type char32_t = __uint_least32_t;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
pub type wchar_t = cty::c_int;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type wint_t = cty::c_uint;
#[doc = " Scalar type that can hold values which represent locale-specific"]
#[doc = "character classifications."]
pub type wctype_t = cty::c_ulong;
#[doc = " The tag name of this struct is _G_fpos_t to preserve historic"]
#[doc = "C++ mangled names for functions taking fpos_t arguments."]
#[doc = "That name should not be used in new code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::core::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
impl Default for _G_fpos_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " The tag name of this struct is _G_fpos_t to preserve historic"]
#[doc = "C++ mangled names for functions taking fpos_t arguments."]
#[doc = "That name should not be used in new code."]
pub type __fpos_t = _G_fpos_t;
#[doc = " The tag name of this struct is _G_fpos64_t to preserve historic"]
#[doc = "C++ mangled names for functions taking fpos_t and/or fpos64_t"]
#[doc = "arguments.  That name should not be used in new code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::core::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
impl Default for _G_fpos64_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " The tag name of this struct is _G_fpos64_t to preserve historic"]
#[doc = "C++ mangled names for functions taking fpos_t and/or fpos64_t"]
#[doc = "arguments.  That name should not be used in new code."]
pub type __fpos64_t = _G_fpos64_t;
#[doc = " The opaque type of streams.  This is the definition used elsewhere."]
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = cty::c_void;
#[doc = " The tag name of this struct is _IO_FILE to preserve historic"]
#[doc = "C++ mangled names for functions taking FILE* arguments."]
#[doc = "That name should not be used in new code."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_FILE {
    #[doc = " High-order word is _IO_MAGIC; rest is flags."]
    pub _flags: cty::c_int,
    #[doc = " Current read pointer"]
    pub _IO_read_ptr: *mut cty::c_char,
    #[doc = " End of get area."]
    pub _IO_read_end: *mut cty::c_char,
    #[doc = " Start of putback+get area."]
    pub _IO_read_base: *mut cty::c_char,
    #[doc = " Start of put area."]
    pub _IO_write_base: *mut cty::c_char,
    #[doc = " Current put pointer."]
    pub _IO_write_ptr: *mut cty::c_char,
    #[doc = " End of put area."]
    pub _IO_write_end: *mut cty::c_char,
    #[doc = " Start of reserve area."]
    pub _IO_buf_base: *mut cty::c_char,
    #[doc = " End of reserve area."]
    pub _IO_buf_end: *mut cty::c_char,
    #[doc = " Pointer to start of non-current get area."]
    pub _IO_save_base: *mut cty::c_char,
    #[doc = " Pointer to first valid character of backup area"]
    pub _IO_backup_base: *mut cty::c_char,
    #[doc = " Pointer to end of non-current get area."]
    pub _IO_save_end: *mut cty::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: cty::c_int,
    pub _flags2: cty::c_int,
    #[doc = " This used to be _offset but it's too small."]
    pub _old_offset: __off_t,
    #[doc = " 1+column number of pbase(); 0 is unknown."]
    pub _cur_column: cty::c_ushort,
    pub _vtable_offset: cty::c_schar,
    pub _shortbuf: [cty::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    #[doc = " Wide character stream stuff."]
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut cty::c_void,
    pub __pad5: size_t,
    pub _mode: cty::c_int,
    #[doc = " Make sure we don't get into trouble again."]
    pub _unused2: [cty::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::core::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
impl Default for _IO_FILE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub static mut optarg: *mut cty::c_char;
}
extern "C" {
    pub static mut optind: cty::c_int;
}
extern "C" {
    pub static mut opterr: cty::c_int;
}
extern "C" {
    pub static mut optopt: cty::c_int;
}
#[doc = " Signed."]
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
#[doc = " Unsigned."]
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
#[doc = " Signed."]
pub type int_fast8_t = cty::c_schar;
pub type int_fast16_t = cty::c_long;
pub type int_fast32_t = cty::c_long;
pub type int_fast64_t = cty::c_long;
#[doc = " Unsigned."]
pub type uint_fast8_t = cty::c_uchar;
pub type uint_fast16_t = cty::c_ulong;
pub type uint_fast32_t = cty::c_ulong;
pub type uint_fast64_t = cty::c_ulong;
#[doc = " Largest integral types."]
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = " Returned by `div'."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct div_t {
    #[doc = " Quotient."]
    pub quot: cty::c_int,
    #[doc = " Remainder."]
    pub rem: cty::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::core::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::core::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ldiv_t {
    #[doc = " Quotient."]
    pub quot: cty::c_long,
    #[doc = " Remainder."]
    pub rem: cty::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::core::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[doc = " Returned by `lldiv'."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct lldiv_t {
    #[doc = " Quotient."]
    pub quot: cty::c_longlong,
    #[doc = " Remainder."]
    pub rem: cty::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::core::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *const cty::c_void, arg2: *const cty::c_void) -> cty::c_int,
>;
#[doc = " An integral type that can be modified atomically, without the"]
#[doc = "possibility of a signal arriving in the middle of the operation."]
pub type sig_atomic_t = __sig_atomic_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __sigset_t {
    pub __val: [cty::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::core::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
#[doc = " A set of signals to be blocked, unblocked, or waited for."]
pub type sigset_t = __sigset_t;
pub type pid_t = __pid_t;
pub type uid_t = __uid_t;
#[doc = " Type of a signal handler."]
pub type __sighandler_t = ::core::option::Option<unsafe extern "C" fn(arg1: cty::c_int)>;
extern "C" {
    #[link_name = "\u{1}__sysv_signal"]
    pub fn signal(__sig: cty::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    #[doc = " Clear all signals from SET."]
    pub fn sigemptyset(__set: *mut sigset_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Set all signals in SET."]
    pub fn sigfillset(__set: *mut sigset_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Add SIGNO to SET."]
    pub fn sigaddset(__set: *mut sigset_t, __signo: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Remove SIGNO from SET."]
    pub fn sigdelset(__set: *mut sigset_t, __signo: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Return 1 if SIGNO is in SET, 0 if not."]
    pub fn sigismember(__set: *const sigset_t, __signo: cty::c_int) -> cty::c_int;
}
#[doc = " Structure describing the action to be taken when a signal arrives."]
#[repr(C)]
pub struct sigaction {
    pub sa_handler: __sighandler_t,
    #[doc = " Additional set of signals to be blocked."]
    pub sa_mask: __sigset_t,
    #[doc = " Special flags."]
    pub sa_flags: cty::c_int,
    #[doc = " Restore handler."]
    pub sa_restorer: ::core::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(
        ::core::mem::size_of::<sigaction>(),
        152usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::core::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigaction>())).sa_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigaction>())).sa_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigaction>())).sa_flags as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigaction>())).sa_restorer as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_restorer)
        )
    );
}
impl Default for sigaction {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Get and/or change the set of blocked signals."]
    pub fn sigprocmask(
        __how: cty::c_int,
        __set: *const sigset_t,
        __oset: *mut sigset_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Change the set of blocked signals to SET,"]
    #[doc = "wait until a signal arrives, and restore the set of blocked signals."]
    #[doc = ""]
    #[doc = "This function is a cancellation point and therefore not marked with"]
    #[doc = "__THROW."]
    pub fn sigsuspend(__set: *const sigset_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Get and/or set the action for signal SIG."]
    pub fn sigaction(
        __sig: cty::c_int,
        __act: *const sigaction,
        __oact: *mut sigaction,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Put in SET all signals that are blocked and waiting to be delivered."]
    pub fn sigpending(__set: *mut sigset_t) -> cty::c_int;
}
#[doc = " Structure for scatter/gather I/O."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct iovec {
    #[doc = " Pointer to data."]
    pub iov_base: *mut cty::c_void,
    #[doc = " Length of data."]
    pub iov_len: size_t,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(
        ::core::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::core::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iovec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
impl Default for iovec {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type off_t = __off_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type key_t = __key_t;
#[doc = " Clock ID used in clock and timer functions."]
pub type clockid_t = __clockid_t;
#[doc = " Timer ID returned by `timer_create'."]
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type suseconds_t = __suseconds_t;
#[doc = " These were defined by ISO C without the first `_'."]
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = cty::c_long;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type socklen_t = __socklen_t;
#[doc = " Sequenced, reliable, connection-based"]
#[doc = "byte streams."]
pub const __socket_type_SOCK_STREAM: __socket_type = 1;
#[doc = " Connectionless, unreliable datagrams"]
#[doc = "of fixed maximum length."]
pub const __socket_type_SOCK_DGRAM: __socket_type = 2;
#[doc = " Raw protocol interface."]
pub const __socket_type_SOCK_RAW: __socket_type = 3;
#[doc = " Reliably-delivered messages."]
pub const __socket_type_SOCK_RDM: __socket_type = 4;
#[doc = " Sequenced, reliable, connection-based,"]
#[doc = "datagrams of fixed maximum length."]
pub const __socket_type_SOCK_SEQPACKET: __socket_type = 5;
#[doc = " Datagram Congestion Control Protocol."]
pub const __socket_type_SOCK_DCCP: __socket_type = 6;
#[doc = " Linux specific way of getting packets"]
#[doc = "at the dev level.  For writing rarp and"]
#[doc = "other similar things on the user level."]
pub const __socket_type_SOCK_PACKET: __socket_type = 10;
#[doc = " Atomically set close-on-exec flag for the"]
#[doc = "new descriptor(s)."]
pub const __socket_type_SOCK_CLOEXEC: __socket_type = 524288;
#[doc = " Atomically mark descriptor(s) as"]
#[doc = "non-blocking."]
pub const __socket_type_SOCK_NONBLOCK: __socket_type = 2048;
#[doc = " Types of sockets."]
pub type __socket_type = cty::c_uint;
#[doc = " POSIX.1g specifies this type name for the `sa_family' member."]
pub type sa_family_t = cty::c_ushort;
#[doc = " Structure describing a generic socket address."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    #[doc = " Address data."]
    pub sa_data: [cty::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(
        ::core::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::core::mem::align_of::<sockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr>())).sa_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr>())).sa_data as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [cty::c_char; 118usize],
    #[doc = " Force desired alignment."]
    pub __ss_align: cty::c_ulong,
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    assert_eq!(
        ::core::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::core::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr_storage>())).ss_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr_storage>())).__ss_padding as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr_storage>())).__ss_align as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_align)
        )
    );
}
impl Default for sockaddr_storage {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Structure describing messages sent by"]
#[doc = "`sendmsg' and received by `recvmsg'."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct msghdr {
    #[doc = " Address to send to/receive from."]
    pub msg_name: *mut cty::c_void,
    #[doc = " Length of address data."]
    pub msg_namelen: socklen_t,
    #[doc = " Vector of data to send/receive into."]
    pub msg_iov: *mut iovec,
    #[doc = " Number of elements in the vector."]
    pub msg_iovlen: size_t,
    #[doc = " Ancillary data (eg BSD filedesc passing)."]
    pub msg_control: *mut cty::c_void,
    #[doc = " Ancillary data buffer length."]
    #[doc = " The type should be socklen_t but the"]
    #[doc = "definition of the kernel is incompatible"]
    #[doc = "with this."]
    pub msg_controllen: size_t,
    #[doc = " Flags on received message."]
    pub msg_flags: cty::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    assert_eq!(
        ::core::mem::size_of::<msghdr>(),
        56usize,
        concat!("Size of: ", stringify!(msghdr))
    );
    assert_eq!(
        ::core::mem::align_of::<msghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(msghdr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<msghdr>())).msg_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<msghdr>())).msg_namelen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_namelen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<msghdr>())).msg_iov as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iov)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<msghdr>())).msg_iovlen as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iovlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<msghdr>())).msg_control as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_control)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<msghdr>())).msg_controllen as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_controllen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<msghdr>())).msg_flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_flags)
        )
    );
}
impl Default for msghdr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Structure used for storage of ancillary data object information."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct cmsghdr {
    #[doc = " Length of data in cmsg_data plus length"]
    #[doc = "of cmsghdr structure."]
    #[doc = " The type should be socklen_t but the"]
    #[doc = "definition of the kernel is incompatible"]
    #[doc = "with this."]
    pub cmsg_len: size_t,
    #[doc = " Originating protocol."]
    pub cmsg_level: cty::c_int,
    #[doc = " Protocol specific type."]
    pub cmsg_type: cty::c_int,
    #[doc = " Ancillary data."]
    pub __cmsg_data: __IncompleteArrayField<cty::c_uchar>,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    assert_eq!(
        ::core::mem::size_of::<cmsghdr>(),
        16usize,
        concat!("Size of: ", stringify!(cmsghdr))
    );
    assert_eq!(
        ::core::mem::align_of::<cmsghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(cmsghdr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cmsghdr>())).cmsg_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cmsghdr>())).cmsg_level as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cmsghdr>())).cmsg_type as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cmsghdr>())).__cmsg_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(__cmsg_data)
        )
    );
}
#[doc = " Structure used to manipulate the SO_LINGER option."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct linger {
    #[doc = " Nonzero to linger on close."]
    pub l_onoff: cty::c_int,
    #[doc = " Time to linger."]
    pub l_linger: cty::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    assert_eq!(
        ::core::mem::size_of::<linger>(),
        8usize,
        concat!("Size of: ", stringify!(linger))
    );
    assert_eq!(
        ::core::mem::align_of::<linger>(),
        4usize,
        concat!("Alignment of ", stringify!(linger))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<linger>())).l_onoff as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_onoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<linger>())).l_linger as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_linger)
        )
    );
}
#[doc = " Internet address."]
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    assert_eq!(
        ::core::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::core::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in_addr>())).s_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr),
            "::",
            stringify!(s_addr)
        )
    );
}
#[doc = " Type to represent a port."]
pub type in_port_t = u16;
#[doc = " IPv6 address"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr8 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr16 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr32)
        )
    );
}
impl Default for in6_addr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(
        ::core::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::core::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<in6_addr>())).__in6_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr),
            "::",
            stringify!(__in6_u)
        )
    );
}
impl Default for in6_addr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static in6addr_any: in6_addr;
}
extern "C" {
    pub static in6addr_loopback: in6_addr;
}
#[doc = " Structure describing an Internet socket address."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    #[doc = " Port number."]
    pub sin_port: in_port_t,
    #[doc = " Internet address."]
    pub sin_addr: in_addr,
    #[doc = " Pad to size of `struct sockaddr'."]
    pub sin_zero: [cty::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    assert_eq!(
        ::core::mem::size_of::<sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_in))
    );
    assert_eq!(
        ::core::mem::align_of::<sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr_in>())).sin_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr_in>())).sin_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr_in>())).sin_addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr_in>())).sin_zero as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_zero)
        )
    );
}
#[doc = " Ditto, for IPv6."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    #[doc = " Transport layer port #"]
    pub sin6_port: in_port_t,
    #[doc = " IPv6 flow information"]
    pub sin6_flowinfo: u32,
    #[doc = " IPv6 address"]
    pub sin6_addr: in6_addr,
    #[doc = " IPv6 scope-id"]
    pub sin6_scope_id: u32,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    assert_eq!(
        ::core::mem::size_of::<sockaddr_in6>(),
        28usize,
        concat!("Size of: ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        ::core::mem::align_of::<sockaddr_in6>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr_in6>())).sin6_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr_in6>())).sin6_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr_in6>())).sin6_flowinfo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_flowinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr_in6>())).sin6_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sockaddr_in6>())).sin6_scope_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_scope_id)
        )
    );
}
impl Default for sockaddr_in6 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Likewise, for IPv6."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    #[doc = " IPv6 multicast address of group"]
    pub ipv6mr_multiaddr: in6_addr,
    #[doc = " local interface"]
    pub ipv6mr_interface: cty::c_uint,
}
#[test]
fn bindgen_test_layout_ipv6_mreq() {
    assert_eq!(
        ::core::mem::size_of::<ipv6_mreq>(),
        20usize,
        concat!("Size of: ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        ::core::mem::align_of::<ipv6_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ipv6_mreq>())).ipv6mr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ipv6_mreq>())).ipv6mr_interface as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_interface)
        )
    );
}
impl Default for ipv6_mreq {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Get a human-readable string describing the running Notcurses version."]
    pub fn notcurses_version() -> *const cty::c_char;
}
extern "C" {
    #[doc = " Cannot be inline, as we want to get the versions of the actual Notcurses"]
    #[doc = " library we loaded, not what we compile against."]
    pub fn notcurses_version_components(
        major: *mut cty::c_int,
        minor: *mut cty::c_int,
        patch: *mut cty::c_int,
        tweak: *mut cty::c_int,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct notcurses {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncplane {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncvisual {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncuplot {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncdplot {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ncprogbar {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncfdplane {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ncsubproc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncselector {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncmultiselector {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncreader {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ncfadectx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nctablet {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncreel {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nctab {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nctabbed {
    _unused: [u8; 0],
}
#[doc = " let the ncvisual pick"]
pub const ncblitter_e_NCBLIT_DEFAULT: ncblitter_e = 0;
#[doc = " space, compatible with ASCII"]
pub const ncblitter_e_NCBLIT_1x1: ncblitter_e = 1;
#[doc = " halves + 1x1 (space)     ▄▀"]
pub const ncblitter_e_NCBLIT_2x1: ncblitter_e = 2;
#[doc = " quadrants + 2x1          ▗▐ ▖▀▟▌▙"]
pub const ncblitter_e_NCBLIT_2x2: ncblitter_e = 3;
#[doc = " sextants (*NOT* 2x2)     🬀🬁🬂🬃🬄🬅🬆🬇🬈🬉🬊🬋🬌🬍🬎🬏🬐🬑🬒🬓🬔🬕🬖🬗🬘🬙🬚🬛🬜🬝🬞"]
pub const ncblitter_e_NCBLIT_3x2: ncblitter_e = 4;
#[doc = " 4 rows, 2 cols (braille) ⡀⡄⡆⡇⢀⣀⣄⣆⣇⢠⣠⣤⣦⣧⢰⣰⣴⣶⣷⢸⣸⣼⣾⣿"]
pub const ncblitter_e_NCBLIT_BRAILLE: ncblitter_e = 5;
#[doc = " pixel graphics"]
pub const ncblitter_e_NCBLIT_PIXEL: ncblitter_e = 6;
#[doc = " four vertical levels     █▆▄▂"]
pub const ncblitter_e_NCBLIT_4x1: ncblitter_e = 7;
#[doc = " eight vertical levels    █▇▆▅▄▃▂▁"]
pub const ncblitter_e_NCBLIT_8x1: ncblitter_e = 8;
#[doc = " we never blit full blocks, but instead spaces (more efficient) with the"]
#[doc = " background set to the desired foreground. these need be kept in the same"]
#[doc = " order as the blitters[] definition in lib/blit.c."]
pub type ncblitter_e = cty::c_uint;
pub const ncalign_e_NCALIGN_UNALIGNED: ncalign_e = 0;
pub const ncalign_e_NCALIGN_LEFT: ncalign_e = 1;
pub const ncalign_e_NCALIGN_CENTER: ncalign_e = 2;
pub const ncalign_e_NCALIGN_RIGHT: ncalign_e = 3;
#[doc = " Alignment within a plane or terminal. Left/right-justified, or centered."]
pub type ncalign_e = cty::c_uint;
pub const ncscale_e_NCSCALE_NONE: ncscale_e = 0;
pub const ncscale_e_NCSCALE_SCALE: ncscale_e = 1;
pub const ncscale_e_NCSCALE_STRETCH: ncscale_e = 2;
pub const ncscale_e_NCSCALE_NONE_HIRES: ncscale_e = 3;
pub const ncscale_e_NCSCALE_SCALE_HIRES: ncscale_e = 4;
#[doc = " How to scale an ncvisual during rendering. NCSCALE_NONE will apply no"]
#[doc = " scaling. NCSCALE_SCALE scales a visual to the plane's size, maintaining"]
#[doc = " aspect ratio. NCSCALE_STRETCH stretches and scales the image in an attempt"]
#[doc = " to fill the entirety of the plane. NCSCALE_NONE_HIRES and"]
#[doc = " NCSCALE_SCALE_HIRES behave like their counterparts, but admit blitters"]
#[doc = " which don't preserve aspect ratio."]
pub type ncscale_e = cty::c_uint;
extern "C" {
    #[doc = " Returns the number of columns occupied by a multibyte (UTF-8) string, or"]
    #[doc = " -1 if a non-printable/illegal character is encountered."]
    pub fn ncstrwidth(mbs: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    #[doc = " input functions like notcurses_getc() return ucs32-encoded char32_t. convert"]
    #[doc = " a series of char32_t to utf8. result must be at least 4 bytes per input"]
    #[doc = " char32_t (6 bytes per char32_t will future-proof against Unicode expansion)."]
    #[doc = " the number of bytes used is returned, or -1 if passed illegal ucs32, or too"]
    #[doc = " small of a buffer."]
    pub fn notcurses_ucs32_to_utf8(
        ucs32: *const char32_t,
        ucs32count: cty::c_uint,
        resultbuf: *mut cty::c_uchar,
        buflen: size_t,
    ) -> cty::c_int;
}
#[doc = " An nccell corresponds to a single character cell on some plane, which can be"]
#[doc = " occupied by a single grapheme cluster (some root spacing glyph, along with"]
#[doc = " possible combining characters, which might span multiple columns). At any"]
#[doc = " cell, we can have a theoretically arbitrarily long UTF-8 string, a foreground"]
#[doc = " color, a background color, and an attribute set. Valid grapheme cluster"]
#[doc = " contents include:"]
#[doc = ""]
#[doc = "  * A NUL terminator,"]
#[doc = "  * A single control character, followed by a NUL terminator,"]
#[doc = "  * At most one spacing character, followed by zero or more nonspacing"]
#[doc = "    characters, followed by a NUL terminator."]
#[doc = ""]
#[doc = " Multi-column characters can only have a single style/color throughout."]
#[doc = " Existence is suffering, and thus wcwidth() is not reliable. It's just"]
#[doc = " quoting whether or not the EGC contains a \"Wide Asian\" double-width"]
#[doc = " character. This is set for some things, like most emoji, and not set for"]
#[doc = " other things, like cuneiform. True display width is a *function of the"]
#[doc = " font and terminal*. Among the longest Unicode codepoints is"]
#[doc = ""]
#[doc = "    U+FDFD ARABIC LIGATURE BISMILLAH AR-RAHMAN AR-RAHEEM ﷽"]
#[doc = ""]
#[doc = " wcwidth() rather optimistically claims this most exalted glyph to occupy"]
#[doc = " a single column. BiDi text is too complicated for me to even get into here."]
#[doc = " Be assured there are no easy answers; ours is indeed a disturbing Universe."]
#[doc = ""]
#[doc = " Each nccell occupies 16 static bytes (128 bits). The surface is thus ~1.6MB"]
#[doc = " for a (pretty large) 500x200 terminal. At 80x43, it's less than 64KB."]
#[doc = " Dynamic requirements (the egcpool) can add up to 16MB to an ncplane, but"]
#[doc = " such large pools are unlikely in common use."]
#[doc = ""]
#[doc = " We implement some small alpha compositing. Foreground and background both"]
#[doc = " have two bits of inverted alpha. The actual grapheme written to a cell is"]
#[doc = " the topmost non-zero grapheme. If its alpha is 00, its foreground color is"]
#[doc = " used unchanged. If its alpha is 10, its foreground color is derived entirely"]
#[doc = " from cells underneath it. Otherwise, the result will be a composite."]
#[doc = " Likewise for the background. If the bottom of a coordinate's zbuffer is"]
#[doc = " reached with a cumulative alpha of zero, the default is used. In this way,"]
#[doc = " a terminal configured with transparent background can be supported through"]
#[doc = " multiple occluding ncplanes. A foreground alpha of 11 requests high-contrast"]
#[doc = " text (relative to the computed background). A background alpha of 11 is"]
#[doc = " currently forbidden."]
#[doc = ""]
#[doc = " Default color takes precedence over palette or RGB, and cannot be used with"]
#[doc = " transparency. Indexed palette takes precedence over RGB. It cannot"]
#[doc = " meaningfully set transparency, but it can be mixed into a cascading color."]
#[doc = " RGB is used if neither default terminal colors nor palette indexing are in"]
#[doc = " play, and fully supports all transparency options."]
#[doc = ""]
#[doc = " This structure is exposed only so that most functions can be inlined. Do not"]
#[doc = " directly modify or access the fields of this structure; use the API."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct nccell {
    #[doc = " 4B → 4B little endian EGC"]
    pub gcluster: u32,
    #[doc = " 1B → 5B (8 bits of zero)"]
    pub gcluster_backstop: u8,
    #[doc = " 1B → 6B (8 bits of EGC column width)"]
    pub width: u8,
    #[doc = " 2B → 8B (16 bits of NCSTYLE_* attributes)"]
    pub stylemask: u16,
    #[doc = " + 8B == 16B"]
    pub channels: u64,
}
#[test]
fn bindgen_test_layout_nccell() {
    assert_eq!(
        ::core::mem::size_of::<nccell>(),
        16usize,
        concat!("Size of: ", stringify!(nccell))
    );
    assert_eq!(
        ::core::mem::align_of::<nccell>(),
        8usize,
        concat!("Alignment of ", stringify!(nccell))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nccell>())).gcluster as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nccell),
            "::",
            stringify!(gcluster)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nccell>())).gcluster_backstop as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nccell),
            "::",
            stringify!(gcluster_backstop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nccell>())).width as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(nccell),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nccell>())).stylemask as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(nccell),
            "::",
            stringify!(stylemask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nccell>())).channels as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nccell),
            "::",
            stringify!(channels)
        )
    );
}
extern "C" {
    #[doc = " Breaks the UTF-8 string in 'gcluster' down, setting up the nccell 'c'."]
    #[doc = " Returns the number of bytes copied out of 'gcluster', or -1 on failure. The"]
    #[doc = " styling of the cell is left untouched, but any resources are released."]
    pub fn nccell_load(n: *mut ncplane, c: *mut nccell, gcluster: *const cty::c_char)
        -> cty::c_int;
}
extern "C" {
    #[doc = " Duplicate 'c' into 'targ'; both must be/will be bound to 'n'. Returns -1 on"]
    #[doc = " failure, and 0 on success."]
    pub fn nccell_duplicate(n: *mut ncplane, targ: *mut nccell, c: *const nccell) -> cty::c_int;
}
extern "C" {
    #[doc = " Release resources held by the nccell 'c'."]
    pub fn nccell_release(n: *mut ncplane, c: *mut nccell);
}
extern "C" {
    #[doc = " return a pointer to the NUL-terminated EGC referenced by 'c'. this pointer"]
    #[doc = " can be invalidated by any further operation on the plane 'n', so...watch out!"]
    pub fn nccell_extended_gcluster(n: *const ncplane, c: *const nccell) -> *const cty::c_char;
}
extern "C" {
    #[doc = " return the number of columns occupied by 'c'. see ncstrwidth() for an"]
    #[doc = " equivalent for multiple EGCs."]
    #[doc = " FIXME promote to static inline for ABI3"]
    pub fn nccell_width(n: *const ncplane, c: *const nccell) -> cty::c_int;
}
#[doc = " default. print nothing once fullscreen service begins"]
pub const ncloglevel_e_NCLOGLEVEL_SILENT: ncloglevel_e = 0;
#[doc = " print diagnostics immediately related to crashing"]
pub const ncloglevel_e_NCLOGLEVEL_PANIC: ncloglevel_e = 1;
#[doc = " we're hanging around, but we've had a horrible fault"]
pub const ncloglevel_e_NCLOGLEVEL_FATAL: ncloglevel_e = 2;
#[doc = " we can't keep doing this, but we can do other things"]
pub const ncloglevel_e_NCLOGLEVEL_ERROR: ncloglevel_e = 3;
#[doc = " you probably don't want what's happening to happen"]
pub const ncloglevel_e_NCLOGLEVEL_WARNING: ncloglevel_e = 4;
#[doc = " \"standard information\""]
pub const ncloglevel_e_NCLOGLEVEL_INFO: ncloglevel_e = 5;
#[doc = " \"detailed information\""]
pub const ncloglevel_e_NCLOGLEVEL_VERBOSE: ncloglevel_e = 6;
#[doc = " this is honestly a bit much"]
pub const ncloglevel_e_NCLOGLEVEL_DEBUG: ncloglevel_e = 7;
#[doc = " there's probably a better way to do what you want"]
pub const ncloglevel_e_NCLOGLEVEL_TRACE: ncloglevel_e = 8;
#[doc = " These log levels consciously map cleanly to those of libav; Notcurses itself"]
#[doc = " does not use this full granularity. The log level does not affect the opening"]
#[doc = " and closing banners, which can be disabled via the notcurses_option struct's"]
#[doc = " 'suppress_banner'. Note that if stderr is connected to the same terminal on"]
#[doc = " which we're rendering, any kind of logging will disrupt the output."]
pub type ncloglevel_e = cty::c_uint;
#[doc = " Configuration for notcurses_init()."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct notcurses_options {
    #[doc = " The name of the terminfo database entry describing this terminal. If NULL,"]
    #[doc = " the environment variable TERM is used. Failure to open the terminal"]
    #[doc = " definition will result in failure to initialize notcurses."]
    pub termtype: *const cty::c_char,
    #[doc = " If non-NULL, notcurses_render() will write each rendered frame to this"]
    #[doc = " FILE* in addition to outfp. This is used primarily for debugging."]
    pub renderfp: *mut FILE,
    #[doc = " Progressively higher log levels result in more logging to stderr. By"]
    #[doc = " default, nothing is printed to stderr once fullscreen service begins."]
    pub loglevel: ncloglevel_e,
    #[doc = " Desirable margins. If all are 0 (default), we will render to the entirety"]
    #[doc = " of the screen. If the screen is too small, we do what we can--this is"]
    #[doc = " strictly best-effort. Absolute coordinates are relative to the rendering"]
    #[doc = " area ((0, 0) is always the origin of the rendering area)."]
    pub margin_t: cty::c_int,
    #[doc = " Desirable margins. If all are 0 (default), we will render to the entirety"]
    #[doc = " of the screen. If the screen is too small, we do what we can--this is"]
    #[doc = " strictly best-effort. Absolute coordinates are relative to the rendering"]
    #[doc = " area ((0, 0) is always the origin of the rendering area)."]
    pub margin_r: cty::c_int,
    #[doc = " Desirable margins. If all are 0 (default), we will render to the entirety"]
    #[doc = " of the screen. If the screen is too small, we do what we can--this is"]
    #[doc = " strictly best-effort. Absolute coordinates are relative to the rendering"]
    #[doc = " area ((0, 0) is always the origin of the rendering area)."]
    pub margin_b: cty::c_int,
    #[doc = " Desirable margins. If all are 0 (default), we will render to the entirety"]
    #[doc = " of the screen. If the screen is too small, we do what we can--this is"]
    #[doc = " strictly best-effort. Absolute coordinates are relative to the rendering"]
    #[doc = " area ((0, 0) is always the origin of the rendering area)."]
    pub margin_l: cty::c_int,
    #[doc = " General flags; see NCOPTION_*. This is expressed as a bitfield so that"]
    #[doc = " future options can be added without reshaping the struct. Undefined bits"]
    #[doc = " must be set to 0."]
    pub flags: u64,
}
#[test]
fn bindgen_test_layout_notcurses_options() {
    assert_eq!(
        ::core::mem::size_of::<notcurses_options>(),
        48usize,
        concat!("Size of: ", stringify!(notcurses_options))
    );
    assert_eq!(
        ::core::mem::align_of::<notcurses_options>(),
        8usize,
        concat!("Alignment of ", stringify!(notcurses_options))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<notcurses_options>())).termtype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(notcurses_options),
            "::",
            stringify!(termtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<notcurses_options>())).renderfp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(notcurses_options),
            "::",
            stringify!(renderfp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<notcurses_options>())).loglevel as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(notcurses_options),
            "::",
            stringify!(loglevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<notcurses_options>())).margin_t as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(notcurses_options),
            "::",
            stringify!(margin_t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<notcurses_options>())).margin_r as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(notcurses_options),
            "::",
            stringify!(margin_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<notcurses_options>())).margin_b as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(notcurses_options),
            "::",
            stringify!(margin_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<notcurses_options>())).margin_l as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(notcurses_options),
            "::",
            stringify!(margin_l)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<notcurses_options>())).flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(notcurses_options),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for notcurses_options {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Lex a margin argument according to the standard Notcurses definition. There"]
    #[doc = " can be either a single number, which will define all margins equally, or"]
    #[doc = " there can be four numbers separated by commas."]
    pub fn notcurses_lex_margins(
        op: *const cty::c_char,
        opts: *mut notcurses_options,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Lex a blitter."]
    pub fn notcurses_lex_blitter(op: *const cty::c_char, blitter: *mut ncblitter_e) -> cty::c_int;
}
extern "C" {
    #[doc = " Get the name of a blitter."]
    pub fn notcurses_str_blitter(blitter: ncblitter_e) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Lex a scaling mode (one of \"none\", \"stretch\", \"scale\", \"hires\","]
    #[doc = " \"scalehi\", or \"inflate\")."]
    pub fn notcurses_lex_scalemode(op: *const cty::c_char, scalemode: *mut ncscale_e)
        -> cty::c_int;
}
extern "C" {
    #[doc = " Get the name of a scaling mode."]
    pub fn notcurses_str_scalemode(scalemode: ncscale_e) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Initialize a Notcurses context on the connected terminal at 'fp'. 'fp' must"]
    #[doc = " be a tty. You'll usually want stdout. NULL can be supplied for 'fp', in"]
    #[doc = " which case /dev/tty will be opened. Returns NULL on error, including any"]
    #[doc = " failure initializing terminfo."]
    pub fn notcurses_init(opts: *const notcurses_options, fp: *mut FILE) -> *mut notcurses;
}
extern "C" {
    #[doc = " The same as notcurses_init(), but without any multimedia functionality,"]
    #[doc = " allowing for a svelter binary. Link with notcurses-core if this is used."]
    pub fn notcurses_core_init(opts: *const notcurses_options, fp: *mut FILE) -> *mut notcurses;
}
extern "C" {
    #[doc = " Destroy a Notcurses context."]
    pub fn notcurses_stop(nc: *mut notcurses) -> cty::c_int;
}
extern "C" {
    #[doc = " Return the topmost plane of the pile containing 'n'."]
    pub fn ncpile_top(n: *mut ncplane) -> *mut ncplane;
}
extern "C" {
    #[doc = " Return the bottommost plane of the pile containing 'n'."]
    pub fn ncpile_bottom(n: *mut ncplane) -> *mut ncplane;
}
extern "C" {
    #[doc = " Renders the pile of which 'n' is a part. Rendering this pile again will blow"]
    #[doc = " away the render. To actually write out the render, call ncpile_rasterize()."]
    pub fn ncpile_render(n: *mut ncplane) -> cty::c_int;
}
extern "C" {
    #[doc = " Make the physical screen match the last rendered frame from the pile of"]
    #[doc = " which 'n' is a part. This is a blocking call. Don't call this before the"]
    #[doc = " pile has been rendered (doing so will likely result in a blank screen)."]
    pub fn ncpile_rasterize(n: *mut ncplane) -> cty::c_int;
}
extern "C" {
    #[doc = " Renders and rasterizes the standard pile in one shot. Blocking call."]
    pub fn notcurses_render(nc: *mut notcurses) -> cty::c_int;
}
extern "C" {
    #[doc = " Perform the rendering and rasterization portion of ncpile_render() and"]
    #[doc = " ncpile_rasterize(), but do not write the resulting buffer out to the"]
    #[doc = " terminal. Using this function, the user can control the writeout process."]
    #[doc = " The returned buffer must be freed by the caller."]
    pub fn ncpile_render_to_buffer(
        p: *mut ncplane,
        buf: *mut *mut cty::c_char,
        buflen: *mut size_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Write the last rendered frame, in its entirety, to 'fp'. If"]
    #[doc = " notcurses_render() has not yet been called, nothing will be written."]
    pub fn ncpile_render_to_file(p: *mut ncplane, fp: *mut FILE) -> cty::c_int;
}
extern "C" {
    #[doc = " Return the topmost ncplane of the standard pile."]
    pub fn notcurses_top(n: *mut notcurses) -> *mut ncplane;
}
extern "C" {
    #[doc = " Return the bottommost ncplane of the standard pile."]
    pub fn notcurses_bottom(n: *mut notcurses) -> *mut ncplane;
}
extern "C" {
    #[doc = " Destroy all ncplanes other than the stdplane."]
    pub fn notcurses_drop_planes(nc: *mut notcurses);
}
#[doc = " An input event. Cell coordinates are currently defined only for mouse events."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncinput {
    #[doc = " identifier. Unicode codepoint or synthesized NCKEY event"]
    pub id: char32_t,
    #[doc = " y cell coordinate of event, -1 for undefined"]
    pub y: cty::c_int,
    #[doc = " x cell coordinate of event, -1 for undefined"]
    pub x: cty::c_int,
    #[doc = " was alt held?"]
    pub alt: bool,
    #[doc = " was shift held?"]
    pub shift: bool,
    #[doc = " was ctrl held?"]
    pub ctrl: bool,
    #[doc = " input event number"]
    pub seqnum: u64,
}
#[test]
fn bindgen_test_layout_ncinput() {
    assert_eq!(
        ::core::mem::size_of::<ncinput>(),
        24usize,
        concat!("Size of: ", stringify!(ncinput))
    );
    assert_eq!(
        ::core::mem::align_of::<ncinput>(),
        8usize,
        concat!("Alignment of ", stringify!(ncinput))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncinput>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncinput),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncinput>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ncinput),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncinput>())).x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncinput),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncinput>())).alt as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ncinput),
            "::",
            stringify!(alt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncinput>())).shift as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(ncinput),
            "::",
            stringify!(shift)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncinput>())).ctrl as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(ncinput),
            "::",
            stringify!(ctrl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncinput>())).seqnum as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncinput),
            "::",
            stringify!(seqnum)
        )
    );
}
extern "C" {
    #[doc = " See ppoll(2) for more detail. Provide a NULL 'ts' to block at length, a 'ts'"]
    #[doc = " of 0 for non-blocking operation, and otherwise a timespec to bound blocking."]
    #[doc = " Signals in sigmask (less several we handle internally) will be atomically"]
    #[doc = " masked and unmasked per ppoll(2). It should generally contain all signals."]
    #[doc = " Returns a single Unicode code point, or (char32_t)-1 on error. 'sigmask' may"]
    #[doc = " be NULL. Returns 0 on a timeout. If an event is processed, the return value"]
    #[doc = " is the 'id' field from that event. 'ni' may be NULL."]
    pub fn notcurses_getc(
        n: *mut notcurses,
        ts: *const timespec,
        sigmask: *const sigset_t,
        ni: *mut ncinput,
    ) -> char32_t;
}
extern "C" {
    #[doc = " Get a file descriptor suitable for input event poll()ing. When this"]
    #[doc = " descriptor becomes available, you can call notcurses_getc_nblock(),"]
    #[doc = " and input ought be ready. This file descriptor is *not* necessarily"]
    #[doc = " the file descriptor associated with stdin (but it might be!)."]
    pub fn notcurses_inputready_fd(n: *mut notcurses) -> cty::c_int;
}
extern "C" {
    #[doc = " Enable the mouse in \"button-event tracking\" mode with focus detection and"]
    #[doc = " UTF8-style extended coordinates. On failure, -1 is returned. On success, 0"]
    #[doc = " is returned, and mouse events will be published to notcurses_getc()."]
    pub fn notcurses_mouse_enable(n: *mut notcurses) -> cty::c_int;
}
extern "C" {
    #[doc = " Disable mouse events. Any events in the input queue can still be delivered."]
    pub fn notcurses_mouse_disable(n: *mut notcurses) -> cty::c_int;
}
extern "C" {
    #[doc = " Disable signals originating from the terminal's line discipline, i.e."]
    #[doc = " SIGINT (^C), SIGQUIT (^\\), and SIGTSTP (^Z). They are enabled by default."]
    pub fn notcurses_linesigs_disable(n: *mut notcurses) -> cty::c_int;
}
extern "C" {
    #[doc = " Restore signals originating from the terminal's line discipline, i.e."]
    #[doc = " SIGINT (^C), SIGQUIT (^\\), and SIGTSTP (^Z), if disabled."]
    pub fn notcurses_linesigs_enable(n: *mut notcurses) -> cty::c_int;
}
extern "C" {
    #[doc = " Refresh the physical screen to match what was last rendered (i.e., without"]
    #[doc = " reflecting any changes since the last call to notcurses_render()). This is"]
    #[doc = " primarily useful if the screen is externally corrupted, or if an"]
    #[doc = " NCKEY_RESIZE event has been read and you're not yet ready to render. The"]
    #[doc = " current screen geometry is returned in 'y' and 'x', if they are not NULL."]
    pub fn notcurses_refresh(
        n: *mut notcurses,
        y: *mut cty::c_int,
        x: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Extract the Notcurses context to which this plane is attached."]
    pub fn ncplane_notcurses(n: *const ncplane) -> *mut notcurses;
}
extern "C" {
    pub fn ncplane_notcurses_const(n: *const ncplane) -> *const notcurses;
}
extern "C" {
    #[doc = " Return the dimensions of this ncplane."]
    pub fn ncplane_dim_yx(n: *const ncplane, y: *mut cty::c_int, x: *mut cty::c_int);
}
extern "C" {
    #[doc = " Get a reference to the standard plane (one matching our current idea of the"]
    #[doc = " terminal size) for this terminal. The standard plane always exists, and its"]
    #[doc = " origin is always at the uppermost, leftmost cell of the terminal."]
    pub fn notcurses_stdplane(nc: *mut notcurses) -> *mut ncplane;
}
extern "C" {
    pub fn notcurses_stdplane_const(nc: *const notcurses) -> *const ncplane;
}
extern "C" {
    #[doc = " Retrieve pixel geometry for the display region ('pxy', 'pxx'), each cell"]
    #[doc = " ('celldimy', 'celldimx'), and the maximum displayable bitmap ('maxbmapy',"]
    #[doc = " 'maxbmapx'). If bitmaps are not supported, 'maxbmapy' and 'maxbmapx' will"]
    #[doc = " be 0. Any of the geometry arguments may be NULL."]
    pub fn ncplane_pixelgeom(
        n: *const ncplane,
        pxy: *mut cty::c_int,
        pxx: *mut cty::c_int,
        celldimy: *mut cty::c_int,
        celldimx: *mut cty::c_int,
        maxbmapy: *mut cty::c_int,
        maxbmapx: *mut cty::c_int,
    );
}
extern "C" {
    #[doc = " Retrieve the contents of the specified cell as last rendered. Returns the EGC"]
    #[doc = " or NULL on error. This EGC must be free()d by the caller. The stylemask and"]
    #[doc = " channels are written to 'stylemask' and 'channels', respectively."]
    pub fn notcurses_at_yx(
        nc: *mut notcurses,
        yoff: cty::c_int,
        xoff: cty::c_int,
        stylemask: *mut u16,
        channels: *mut u64,
    ) -> *mut cty::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncplane_options {
    #[doc = " vertical placement relative to parent plane"]
    pub y: cty::c_int,
    #[doc = " horizontal placement relative to parent plane"]
    pub x: cty::c_int,
    #[doc = " rows, must be positive (unless NCPLANE_OPTION_MARGINALIZED)"]
    pub rows: cty::c_int,
    #[doc = " columns, must be positive (unless NCPLANE_OPTION_MARGINALIZED)"]
    pub cols: cty::c_int,
    #[doc = " user curry, may be NULL"]
    pub userptr: *mut cty::c_void,
    #[doc = " name (used only for debugging), may be NULL"]
    pub name: *const cty::c_char,
    #[doc = " callback when parent is resized"]
    pub resizecb: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ncplane) -> cty::c_int>,
    #[doc = " closure over NCPLANE_OPTION_*"]
    pub flags: u64,
    #[doc = " margins (require NCPLANE_OPTION_MARGINALIZED)"]
    pub margin_b: cty::c_int,
    #[doc = " margins (require NCPLANE_OPTION_MARGINALIZED)"]
    pub margin_r: cty::c_int,
}
#[test]
fn bindgen_test_layout_ncplane_options() {
    assert_eq!(
        ::core::mem::size_of::<ncplane_options>(),
        56usize,
        concat!("Size of: ", stringify!(ncplane_options))
    );
    assert_eq!(
        ::core::mem::align_of::<ncplane_options>(),
        8usize,
        concat!("Alignment of ", stringify!(ncplane_options))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplane_options>())).y as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplane_options),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplane_options>())).x as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplane_options),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplane_options>())).rows as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplane_options),
            "::",
            stringify!(rows)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplane_options>())).cols as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplane_options),
            "::",
            stringify!(cols)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplane_options>())).userptr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplane_options),
            "::",
            stringify!(userptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplane_options>())).name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplane_options),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplane_options>())).resizecb as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplane_options),
            "::",
            stringify!(resizecb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplane_options>())).flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplane_options),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplane_options>())).margin_b as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplane_options),
            "::",
            stringify!(margin_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplane_options>())).margin_r as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplane_options),
            "::",
            stringify!(margin_r)
        )
    );
}
impl Default for ncplane_options {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Create a new ncplane bound to plane 'n', at the offset 'y'x'x' (relative to"]
    #[doc = " the origin of 'n') and the specified size. The number of 'rows' and 'cols'"]
    #[doc = " must both be positive. This plane is initially at the top of the z-buffer,"]
    #[doc = " as if ncplane_move_top() had been called on it. The void* 'userptr' can be"]
    #[doc = " retrieved (and reset) later. A 'name' can be set, used in debugging."]
    pub fn ncplane_create(n: *mut ncplane, nopts: *const ncplane_options) -> *mut ncplane;
}
extern "C" {
    #[doc = " Same as ncplane_create(), but creates a new pile. The returned plane will"]
    #[doc = " be the top, bottom, and root of this new pile."]
    pub fn ncpile_create(nc: *mut notcurses, nopts: *const ncplane_options) -> *mut ncplane;
}
extern "C" {
    #[doc = " Suitable for use as a 'resizecb', this will resize the plane to the visual"]
    #[doc = " region's size. It is used for the standard plane."]
    pub fn ncplane_resize_maximize(n: *mut ncplane) -> cty::c_int;
}
extern "C" {
    #[doc = " Suitable for use as a 'resizecb' with planes created with"]
    #[doc = " NCPLANE_OPTION_MARGINALIZED. This will resize the plane 'n' against its"]
    #[doc = " parent, attempting to enforce the supplied margins."]
    pub fn ncplane_resize_marginalized(n: *mut ncplane) -> cty::c_int;
}
extern "C" {
    #[doc = " Suitable for use as a 'resizecb'. This will realign the plane 'n' against"]
    #[doc = " its parent, using the alignment specified at ncplane_create()-time."]
    pub fn ncplane_resize_realign(n: *mut ncplane) -> cty::c_int;
}
extern "C" {
    #[doc = " Replace the ncplane's existing resizecb with 'resizecb' (which may be NULL)."]
    #[doc = " The standard plane's resizecb may not be changed."]
    pub fn ncplane_set_resizecb(
        n: *mut ncplane,
        resizecb: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ncplane) -> cty::c_int>,
    );
}
extern "C" {
    #[doc = " Returns the ncplane's current resize callback."]
    pub fn ncplane_resizecb(
        n: *const ncplane,
    ) -> ::core::option::Option<unsafe extern "C" fn(n: *mut ncplane) -> cty::c_int>;
}
extern "C" {
    #[doc = " Plane 'n' will be unbound from its parent plane, and will be made a bound"]
    #[doc = " child of 'newparent'. It is an error if 'n' or 'newparent' are NULL. If"]
    #[doc = " 'newparent' is equal to 'n', 'n' becomes the root of a new pile, unless 'n'"]
    #[doc = " is already the root of a pile, in which case this is a no-op. Returns 'n'."]
    #[doc = " The standard plane cannot be reparented. Any planes bound to 'n' are"]
    #[doc = " reparented to the previous parent of 'n'."]
    pub fn ncplane_reparent(n: *mut ncplane, newparent: *mut ncplane) -> *mut ncplane;
}
extern "C" {
    #[doc = " The same as ncplane_reparent(), except any planes bound to 'n' come along"]
    #[doc = " with it to its new destination. Their z-order is maintained. If 'newparent'"]
    #[doc = " is an ancestor of 'n', NULL is returned, and no changes are made."]
    pub fn ncplane_reparent_family(n: *mut ncplane, newparent: *mut ncplane) -> *mut ncplane;
}
extern "C" {
    #[doc = " Duplicate an existing ncplane. The new plane will have the same geometry,"]
    #[doc = " will duplicate all content, and will start with the same rendering state."]
    #[doc = " The new plane will be immediately above the old one on the z axis, and will"]
    #[doc = " be bound to the same parent. Bound planes are *not* duplicated; the new"]
    #[doc = " plane is bound to the parent of 'n', but has no bound planes."]
    pub fn ncplane_dup(n: *const ncplane, opaque: *mut cty::c_void) -> *mut ncplane;
}
extern "C" {
    #[doc = " provided a coordinate relative to the origin of 'src', map it to the same"]
    #[doc = " absolute coordinate relative to the origin of 'dst'. either or both of 'y'"]
    #[doc = " and 'x' may be NULL. if 'dst' is NULL, it is taken to be the standard plane."]
    pub fn ncplane_translate(
        src: *const ncplane,
        dst: *const ncplane,
        y: *mut cty::c_int,
        x: *mut cty::c_int,
    );
}
extern "C" {
    #[doc = " Fed absolute 'y'/'x' coordinates, determine whether that coordinate is"]
    #[doc = " within the ncplane 'n'. If not, return false. If so, return true. Either"]
    #[doc = " way, translate the absolute coordinates relative to 'n'. If the point is not"]
    #[doc = " within 'n', these coordinates will not be within the dimensions of the plane."]
    pub fn ncplane_translate_abs(n: *const ncplane, y: *mut cty::c_int, x: *mut cty::c_int)
        -> bool;
}
extern "C" {
    #[doc = " All planes are created with scrolling disabled. Scrolling can be dynamically"]
    #[doc = " controlled with ncplane_set_scrolling(). Returns true if scrolling was"]
    #[doc = " previously enabled, or false if it was disabled."]
    pub fn ncplane_set_scrolling(n: *mut ncplane, scrollp: bool) -> bool;
}
extern "C" {
    pub fn ncplane_scrolling_p(n: *const ncplane) -> bool;
}
#[doc = " Palette API. Some terminals only support 256 colors, but allow the full"]
#[doc = " palette to be specified with arbitrary RGB colors. In all cases, it's more"]
#[doc = " performant to use indexed colors, since it's much less data to write to the"]
#[doc = " terminal. If you can limit yourself to 256 colors, that's probably best."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ncpalette {
    #[doc = " RGB values as regular ol' channels"]
    pub chans: [u32; 256usize],
}
#[test]
fn bindgen_test_layout_ncpalette() {
    assert_eq!(
        ::core::mem::size_of::<ncpalette>(),
        1024usize,
        concat!("Size of: ", stringify!(ncpalette))
    );
    assert_eq!(
        ::core::mem::align_of::<ncpalette>(),
        4usize,
        concat!("Alignment of ", stringify!(ncpalette))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncpalette>())).chans as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncpalette),
            "::",
            stringify!(chans)
        )
    );
}
impl Default for ncpalette {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Create a new palette store. It will be initialized with notcurses' best"]
    #[doc = " knowledge of the currently configured palette. The palette upon startup"]
    #[doc = " cannot be reliably detected, sadly."]
    pub fn ncpalette_new(nc: *mut notcurses) -> *mut ncpalette;
}
extern "C" {
    #[doc = " Attempt to configure the terminal with the provided palette 'p'. Does not"]
    #[doc = " transfer ownership of 'p'; ncpalette_free() can (ought) still be called."]
    pub fn ncpalette_use(nc: *mut notcurses, p: *const ncpalette) -> cty::c_int;
}
extern "C" {
    #[doc = " Free the palette store 'p'."]
    pub fn ncpalette_free(p: *mut ncpalette);
}
#[doc = " Capabilities, derived from terminfo, environment variables, and queries"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct nccapabilities {
    #[doc = " size of palette for indexed colors"]
    pub colors: cty::c_uint,
    #[doc = " are we using utf-8 encoding? from nl_langinfo(3)"]
    pub utf8: bool,
    #[doc = " 24bit color? COLORTERM/heuristics/terminfo 'rgb'"]
    pub rgb: bool,
    #[doc = " can we change the palette? terminfo 'ccc'"]
    pub can_change_colors: bool,
    #[doc = " do we have (good, vetted) Unicode 1 quadrant support?"]
    pub quadrants: bool,
    #[doc = " do we have (good, vetted) Unicode 13 sextant support?"]
    pub sextants: bool,
    #[doc = " do we have Braille support? (linux console does not)"]
    pub braille: bool,
}
#[test]
fn bindgen_test_layout_nccapabilities() {
    assert_eq!(
        ::core::mem::size_of::<nccapabilities>(),
        12usize,
        concat!("Size of: ", stringify!(nccapabilities))
    );
    assert_eq!(
        ::core::mem::align_of::<nccapabilities>(),
        4usize,
        concat!("Alignment of ", stringify!(nccapabilities))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nccapabilities>())).colors as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nccapabilities),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nccapabilities>())).utf8 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nccapabilities),
            "::",
            stringify!(utf8)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nccapabilities>())).rgb as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(nccapabilities),
            "::",
            stringify!(rgb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nccapabilities>())).can_change_colors as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(nccapabilities),
            "::",
            stringify!(can_change_colors)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nccapabilities>())).quadrants as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(nccapabilities),
            "::",
            stringify!(quadrants)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nccapabilities>())).sextants as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nccapabilities),
            "::",
            stringify!(sextants)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nccapabilities>())).braille as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(nccapabilities),
            "::",
            stringify!(braille)
        )
    );
}
extern "C" {
    #[doc = " Returns a 16-bit bitmask of supported curses-style attributes"]
    #[doc = " (NCSTYLE_UNDERLINE, NCSTYLE_BOLD, etc.) The attribute is only"]
    #[doc = " indicated as supported if the terminal can support it together with color."]
    #[doc = " For more information, see the \"ncv\" capability in terminfo(5)."]
    pub fn notcurses_supported_styles(nc: *const notcurses) -> cty::c_uint;
}
extern "C" {
    #[doc = " Returns the number of simultaneous colors claimed to be supported, or 1 if"]
    #[doc = " there is no color support. Note that several terminal emulators advertise"]
    #[doc = " more colors than they actually support, downsampling internally."]
    pub fn notcurses_palette_size(nc: *const notcurses) -> cty::c_uint;
}
extern "C" {
    pub fn notcurses_detected_terminal(nc: *const notcurses) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Can we directly specify RGB values per cell, or only use palettes?"]
    pub fn notcurses_cantruecolor(nc: *const notcurses) -> bool;
}
extern "C" {
    #[doc = " Can we fade? Fading requires either the \"rgb\" or \"ccc\" terminfo capability."]
    pub fn notcurses_canfade(nc: *const notcurses) -> bool;
}
extern "C" {
    pub fn notcurses_canchangecolor(nc: *const notcurses) -> bool;
}
extern "C" {
    #[doc = " Can we load images? This requires being built against FFmpeg/OIIO."]
    pub fn notcurses_canopen_images(nc: *const notcurses) -> bool;
}
extern "C" {
    #[doc = " Can we load videos? This requires being built against FFmpeg."]
    pub fn notcurses_canopen_videos(nc: *const notcurses) -> bool;
}
extern "C" {
    #[doc = " Is our encoding UTF-8? Requires LANG being set to a UTF8 locale."]
    pub fn notcurses_canutf8(nc: *const notcurses) -> bool;
}
extern "C" {
    #[doc = " Can we reliably use Unicode halfblocks?"]
    pub fn notcurses_canhalfblock(nc: *const notcurses) -> bool;
}
extern "C" {
    #[doc = " Can we reliably use Unicode quadrants?"]
    pub fn notcurses_canquadrant(nc: *const notcurses) -> bool;
}
extern "C" {
    #[doc = " Can we reliably use Unicode 13 sextants?"]
    pub fn notcurses_cansextant(nc: *const notcurses) -> bool;
}
extern "C" {
    #[doc = " Can we reliably use Unicode Braille?"]
    pub fn notcurses_canbraille(nc: *const notcurses) -> bool;
}
extern "C" {
    #[doc = " Can we blit pixel-accurate bitmaps?"]
    pub fn notcurses_check_pixel_support(nc: *const notcurses) -> cty::c_int;
}
#[doc = " whenever a new field is added here, ensure we add the proper rule to"]
#[doc = " notcurses_stats_reset(), so that values are preserved in the stash stats."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncstats {
    #[doc = " successful ncpile_render() runs"]
    pub renders: u64,
    #[doc = " successful ncpile_rasterize() runs"]
    pub writeouts: u64,
    #[doc = " aborted renders, should be 0"]
    pub failed_renders: u64,
    #[doc = " aborted writes"]
    pub failed_writeouts: u64,
    #[doc = " bytes emitted to ttyfp"]
    pub render_bytes: u64,
    #[doc = " max bytes emitted for a frame"]
    pub render_max_bytes: i64,
    #[doc = " min bytes emitted for a frame"]
    pub render_min_bytes: i64,
    #[doc = " nanoseconds spent rendering"]
    pub render_ns: u64,
    #[doc = " max ns spent in render for a frame"]
    pub render_max_ns: i64,
    #[doc = " min ns spent in render for a frame"]
    pub render_min_ns: i64,
    #[doc = " nanoseconds spent writing frames to terminal"]
    pub writeout_ns: u64,
    #[doc = " max ns spent writing out a frame"]
    pub writeout_max_ns: i64,
    #[doc = " min ns spent writing out a frame"]
    pub writeout_min_ns: i64,
    #[doc = " cells we elided entirely thanks to damage maps"]
    pub cellelisions: u64,
    #[doc = " total number of cells emitted to terminal"]
    pub cellemissions: u64,
    #[doc = " RGB fg elision count"]
    pub fgelisions: u64,
    #[doc = " RGB fg emissions"]
    pub fgemissions: u64,
    #[doc = " RGB bg elision count"]
    pub bgelisions: u64,
    #[doc = " RGB bg emissions"]
    pub bgemissions: u64,
    #[doc = " default color was emitted"]
    pub defaultelisions: u64,
    #[doc = " default color was elided"]
    pub defaultemissions: u64,
    #[doc = " refresh requests (non-optimized redraw)"]
    pub refreshes: u64,
    #[doc = " how many application-synchronized updates?"]
    pub appsync_updates: u64,
    #[doc = " total bytes devoted to all active framebuffers"]
    pub fbbytes: u64,
    #[doc = " number of planes currently in existence"]
    pub planes: cty::c_uint,
    #[doc = " nanoseconds spent rasterizing"]
    pub raster_ns: u64,
    #[doc = " max ns spent in raster for a frame"]
    pub raster_max_ns: i64,
    #[doc = " min ns spent in raster for a frame"]
    pub raster_min_ns: i64,
    #[doc = " sprixel draw count"]
    pub sprixelemissions: u64,
    #[doc = " sprixel elision count"]
    pub sprixelelisions: u64,
    #[doc = " sprixel bytes emitted"]
    pub sprixelbytes: u64,
}
#[test]
fn bindgen_test_layout_ncstats() {
    assert_eq!(
        ::core::mem::size_of::<ncstats>(),
        248usize,
        concat!("Size of: ", stringify!(ncstats))
    );
    assert_eq!(
        ::core::mem::align_of::<ncstats>(),
        8usize,
        concat!("Alignment of ", stringify!(ncstats))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).renders as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(renders)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).writeouts as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(writeouts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).failed_renders as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(failed_renders)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).failed_writeouts as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(failed_writeouts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).render_bytes as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(render_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).render_max_bytes as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(render_max_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).render_min_bytes as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(render_min_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).render_ns as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(render_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).render_max_ns as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(render_max_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).render_min_ns as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(render_min_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).writeout_ns as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(writeout_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).writeout_max_ns as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(writeout_max_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).writeout_min_ns as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(writeout_min_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).cellelisions as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(cellelisions)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).cellemissions as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(cellemissions)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).fgelisions as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(fgelisions)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).fgemissions as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(fgemissions)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).bgelisions as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(bgelisions)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).bgemissions as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(bgemissions)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).defaultelisions as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(defaultelisions)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).defaultemissions as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(defaultemissions)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).refreshes as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(refreshes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).appsync_updates as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(appsync_updates)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).fbbytes as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(fbbytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).planes as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(planes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).raster_ns as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(raster_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).raster_max_ns as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(raster_max_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).raster_min_ns as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(raster_min_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).sprixelemissions as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(sprixelemissions)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).sprixelelisions as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(sprixelelisions)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncstats>())).sprixelbytes as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ncstats),
            "::",
            stringify!(sprixelbytes)
        )
    );
}
extern "C" {
    #[doc = " Allocate an ncstats object. Use this rather than allocating your own, since"]
    #[doc = " future versions of Notcurses might enlarge this structure."]
    pub fn notcurses_stats_alloc(nc: *const notcurses) -> *mut ncstats;
}
extern "C" {
    #[doc = " Acquire an atomic snapshot of the Notcurses object's stats."]
    pub fn notcurses_stats(nc: *mut notcurses, stats: *mut ncstats);
}
extern "C" {
    #[doc = " Reset all cumulative stats (immediate ones, such as fbbytes, are not reset),"]
    #[doc = " first copying them into |*stats| (if |stats| is not NULL)."]
    pub fn notcurses_stats_reset(nc: *mut notcurses, stats: *mut ncstats);
}
extern "C" {
    #[doc = " Resize the specified ncplane. The four parameters 'keepy', 'keepx',"]
    #[doc = " 'keepleny', and 'keeplenx' define a subset of the ncplane to keep,"]
    #[doc = " unchanged. This may be a section of size 0, though none of these four"]
    #[doc = " parameters may be negative. 'keepx' and 'keepy' are relative to the ncplane."]
    #[doc = " They must specify a coordinate within the ncplane's totality. 'yoff' and"]
    #[doc = " 'xoff' are relative to 'keepy' and 'keepx', and place the upper-left corner"]
    #[doc = " of the resized ncplane. Finally, 'ylen' and 'xlen' are the dimensions of the"]
    #[doc = " ncplane after resizing. 'ylen' must be greater than or equal to 'keepleny',"]
    #[doc = " and 'xlen' must be greater than or equal to 'keeplenx'. It is an error to"]
    #[doc = " attempt to resize the standard plane. If either of 'keepleny' or 'keeplenx'"]
    #[doc = " is non-zero, both must be non-zero."]
    #[doc = ""]
    #[doc = " Essentially, the kept material does not move. It serves to anchor the"]
    #[doc = " resized plane. If there is no kept material, the plane can move freely."]
    pub fn ncplane_resize(
        n: *mut ncplane,
        keepy: cty::c_int,
        keepx: cty::c_int,
        keepleny: cty::c_int,
        keeplenx: cty::c_int,
        yoff: cty::c_int,
        xoff: cty::c_int,
        ylen: cty::c_int,
        xlen: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Destroy the specified ncplane. None of its contents will be visible after"]
    #[doc = " the next call to notcurses_render(). It is an error to attempt to destroy"]
    #[doc = " the standard plane."]
    pub fn ncplane_destroy(n: *mut ncplane) -> cty::c_int;
}
extern "C" {
    #[doc = " Set the ncplane's base nccell to 'c'. The base cell is used for purposes of"]
    #[doc = " rendering anywhere that the ncplane's gcluster is 0. Note that the base cell"]
    #[doc = " is not affected by ncplane_erase(). 'c' must not be a secondary cell from a"]
    #[doc = " multicolumn EGC."]
    pub fn ncplane_set_base_cell(n: *mut ncplane, c: *const nccell) -> cty::c_int;
}
extern "C" {
    #[doc = " Set the ncplane's base nccell. It will be used for purposes of rendering"]
    #[doc = " anywhere that the ncplane's gcluster is 0. Note that the base cell is not"]
    #[doc = " affected by ncplane_erase(). 'egc' must be an extended grapheme cluster."]
    #[doc = " Returns the number of bytes copied out of 'gcluster', or -1 on failure."]
    pub fn ncplane_set_base(
        n: *mut ncplane,
        egc: *const cty::c_char,
        stylemask: u32,
        channels: u64,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Extract the ncplane's base nccell into 'c'. The reference is invalidated if"]
    #[doc = " 'ncp' is destroyed."]
    pub fn ncplane_base(n: *mut ncplane, c: *mut nccell) -> cty::c_int;
}
extern "C" {
    #[doc = " Move this plane relative to the standard plane, or the plane to which it is"]
    #[doc = " bound (if it is bound to a plane). It is an error to attempt to move the"]
    #[doc = " standard plane."]
    pub fn ncplane_move_yx(n: *mut ncplane, y: cty::c_int, x: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Get the origin of plane 'n' relative to its bound plane, or pile (if 'n' is"]
    #[doc = " a root plane). To get absolute coordinates, use ncplane_abs_yx()."]
    pub fn ncplane_yx(n: *const ncplane, y: *mut cty::c_int, x: *mut cty::c_int);
}
extern "C" {
    pub fn ncplane_y(n: *const ncplane) -> cty::c_int;
}
extern "C" {
    pub fn ncplane_x(n: *const ncplane) -> cty::c_int;
}
extern "C" {
    #[doc = " Get the origin of plane 'n' relative to its pile. Either or both of 'x' and"]
    #[doc = " 'y' may be NULL."]
    pub fn ncplane_abs_yx(n: *const ncplane, y: *mut cty::c_int, x: *mut cty::c_int);
}
extern "C" {
    pub fn ncplane_abs_y(n: *const ncplane) -> cty::c_int;
}
extern "C" {
    pub fn ncplane_abs_x(n: *const ncplane) -> cty::c_int;
}
extern "C" {
    #[doc = " Get the plane to which the plane 'n' is bound, if any."]
    pub fn ncplane_parent(n: *mut ncplane) -> *mut ncplane;
}
extern "C" {
    pub fn ncplane_parent_const(n: *const ncplane) -> *const ncplane;
}
extern "C" {
    #[doc = " Splice ncplane 'n' out of the z-buffer, and reinsert it at the top or bottom."]
    pub fn ncplane_move_top(n: *mut ncplane);
}
extern "C" {
    pub fn ncplane_move_bottom(n: *mut ncplane);
}
extern "C" {
    #[doc = " Splice ncplane 'n' out of the z-buffer, and reinsert it above 'above'."]
    #[doc = " Returns non-zero if 'n' is already in the desired location. 'n' and"]
    #[doc = " 'above' must not be the same plane."]
    pub fn ncplane_move_above(n: *mut ncplane, above: *mut ncplane) -> cty::c_int;
}
extern "C" {
    #[doc = " Splice ncplane 'n' out of the z-buffer, and reinsert it below 'below'."]
    #[doc = " Returns non-zero if 'n' is already in the desired location. 'n' and"]
    #[doc = " 'below' must not be the same plane."]
    pub fn ncplane_move_below(n: *mut ncplane, below: *mut ncplane) -> cty::c_int;
}
extern "C" {
    #[doc = " Return the plane below this one, or NULL if this is at the bottom."]
    pub fn ncplane_below(n: *mut ncplane) -> *mut ncplane;
}
extern "C" {
    pub fn ncplane_above(n: *mut ncplane) -> *mut ncplane;
}
extern "C" {
    #[doc = " Rotate the plane π/2 radians clockwise or counterclockwise. This cannot"]
    #[doc = " be performed on arbitrary planes, because glyphs cannot be arbitrarily"]
    #[doc = " rotated. The glyphs which can be rotated are limited: line-drawing"]
    #[doc = " characters, spaces, half blocks, and full blocks. The plane must have"]
    #[doc = " an even number of columns. Use the ncvisual rotation for a more"]
    #[doc = " flexible approach."]
    pub fn ncplane_rotate_cw(n: *mut ncplane) -> cty::c_int;
}
extern "C" {
    pub fn ncplane_rotate_ccw(n: *mut ncplane) -> cty::c_int;
}
extern "C" {
    #[doc = " Retrieve the current contents of the cell under the cursor. The EGC is"]
    #[doc = " returned, or NULL on error. This EGC must be free()d by the caller. The"]
    #[doc = " stylemask and channels are written to 'stylemask' and 'channels', respectively."]
    pub fn ncplane_at_cursor(
        n: *mut ncplane,
        stylemask: *mut u16,
        channels: *mut u64,
    ) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " Retrieve the current contents of the cell under the cursor into 'c'. This"]
    #[doc = " cell is invalidated if the associated plane is destroyed. Returns the number"]
    #[doc = " of bytes in the EGC, or -1 on error."]
    pub fn ncplane_at_cursor_cell(n: *mut ncplane, c: *mut nccell) -> cty::c_int;
}
extern "C" {
    #[doc = " Retrieve the current contents of the specified cell. The EGC is returned, or"]
    #[doc = " NULL on error. This EGC must be free()d by the caller. The stylemask and"]
    #[doc = " channels are written to 'stylemask' and 'channels', respectively. The return"]
    #[doc = " represents how the cell will be used during rendering, and thus integrates"]
    #[doc = " any base cell where appropriate. If called upon the secondary columns of a"]
    #[doc = " wide glyph, the EGC will be returned (i.e. this function does not distinguish"]
    #[doc = " between the primary and secondary columns of a wide glyph)."]
    pub fn ncplane_at_yx(
        n: *const ncplane,
        y: cty::c_int,
        x: cty::c_int,
        stylemask: *mut u16,
        channels: *mut u64,
    ) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " Retrieve the current contents of the specified cell into 'c'. This cell is"]
    #[doc = " invalidated if the associated plane is destroyed. Returns the number of"]
    #[doc = " bytes in the EGC, or -1 on error. Unlike ncplane_at_yx(), when called upon"]
    #[doc = " the secondary columns of a wide glyph, the return can be distinguished from"]
    #[doc = " the primary column (nccell_wide_right_p(c) will return true)."]
    pub fn ncplane_at_yx_cell(
        n: *mut ncplane,
        y: cty::c_int,
        x: cty::c_int,
        c: *mut nccell,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Create a flat string from the EGCs of the selected region of the ncplane"]
    #[doc = " 'n'. Start at the plane's 'begy'x'begx' coordinate (which must lie on the"]
    #[doc = " plane), continuing for 'leny'x'lenx' cells. Either or both of 'leny' and"]
    #[doc = " 'lenx' can be specified as -1 to go through the boundary of the plane."]
    pub fn ncplane_contents(
        n: *mut ncplane,
        begy: cty::c_int,
        begx: cty::c_int,
        leny: cty::c_int,
        lenx: cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " Manipulate the opaque user pointer associated with this plane."]
    #[doc = " ncplane_set_userptr() returns the previous userptr after replacing"]
    #[doc = " it with 'opaque'. the others simply return the userptr."]
    pub fn ncplane_set_userptr(n: *mut ncplane, opaque: *mut cty::c_void) -> *mut cty::c_void;
}
extern "C" {
    pub fn ncplane_userptr(n: *mut ncplane) -> *mut cty::c_void;
}
extern "C" {
    pub fn ncplane_center_abs(n: *const ncplane, y: *mut cty::c_int, x: *mut cty::c_int);
}
extern "C" {
    #[doc = " Move the cursor to the specified position (the cursor needn't be visible)."]
    #[doc = " Returns -1 on error, including negative parameters, or ones exceeding the"]
    #[doc = " plane's dimensions."]
    pub fn ncplane_cursor_move_yx(n: *mut ncplane, y: cty::c_int, x: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Move the cursor to 0, 0. Can't fail."]
    pub fn ncplane_home(n: *mut ncplane);
}
extern "C" {
    #[doc = " Get the current position of the cursor within n. y and/or x may be NULL."]
    pub fn ncplane_cursor_yx(n: *const ncplane, y: *mut cty::c_int, x: *mut cty::c_int);
}
extern "C" {
    #[doc = " Get the current channels or attribute word for ncplane 'n'."]
    pub fn ncplane_channels(n: *const ncplane) -> u64;
}
extern "C" {
    #[doc = " Return the current styling for this ncplane."]
    pub fn ncplane_styles(n: *const ncplane) -> u16;
}
extern "C" {
    #[doc = " Replace the cell at the specified coordinates with the provided cell 'c',"]
    #[doc = " and advance the cursor by the width of the cell (but not past the end of the"]
    #[doc = " plane). On success, returns the number of columns the cursor was advanced."]
    #[doc = " 'c' must already be associated with 'n'. On failure, -1 is returned."]
    pub fn ncplane_putc_yx(
        n: *mut ncplane,
        y: cty::c_int,
        x: cty::c_int,
        c: *const nccell,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Replace the EGC underneath us, but retain the styling. The current styling"]
    #[doc = " of the plane will not be changed."]
    pub fn ncplane_putchar_stained(n: *mut ncplane, c: cty::c_char) -> cty::c_int;
}
extern "C" {
    #[doc = " Replace the cell at the specified coordinates with the provided EGC, and"]
    #[doc = " advance the cursor by the width of the cluster (but not past the end of the"]
    #[doc = " plane). On success, returns the number of columns the cursor was advanced."]
    #[doc = " On failure, -1 is returned. The number of bytes converted from gclust is"]
    #[doc = " written to 'sbytes' if non-NULL."]
    pub fn ncplane_putegc_yx(
        n: *mut ncplane,
        y: cty::c_int,
        x: cty::c_int,
        gclust: *const cty::c_char,
        sbytes: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Replace the EGC underneath us, but retain the styling. The current styling"]
    #[doc = " of the plane will not be changed."]
    pub fn ncplane_putegc_stained(
        n: *mut ncplane,
        gclust: *const cty::c_char,
        sbytes: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Replace the EGC underneath us, but retain the styling. The current styling"]
    #[doc = " of the plane will not be changed."]
    pub fn ncplane_putwegc_stained(
        n: *mut ncplane,
        gclust: *const wchar_t,
        sbytes: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Write a series of EGCs to the current location, using the current style."]
    #[doc = " They will be interpreted as a series of columns (according to the definition"]
    #[doc = " of ncplane_putc()). Advances the cursor by some positive number of columns"]
    #[doc = " (though not beyond the end of the plane); this number is returned on success."]
    #[doc = " On error, a non-positive number is returned, indicating the number of columns"]
    #[doc = " which were written before the error."]
    pub fn ncplane_putstr_yx(
        n: *mut ncplane,
        y: cty::c_int,
        x: cty::c_int,
        gclusters: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn ncplane_putstr_aligned(
        n: *mut ncplane,
        y: cty::c_int,
        align: ncalign_e,
        s: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Replace a string's worth of glyphs at the current cursor location, but"]
    #[doc = " retain the styling. The current styling of the plane will not be changed."]
    pub fn ncplane_putstr_stained(n: *mut ncplane, s: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    #[doc = " Write a series of EGCs to the current location, using the current style."]
    #[doc = " They will be interpreted as a series of columns (according to the definition"]
    #[doc = " of ncplane_putc()). Advances the cursor by some positive number of columns"]
    #[doc = " (though not beyond the end of the plane); this number is returned on success."]
    #[doc = " On error, a non-positive number is returned, indicating the number of columns"]
    #[doc = " which were written before the error. No more than 's' bytes will be written."]
    pub fn ncplane_putnstr_yx(
        n: *mut ncplane,
        y: cty::c_int,
        x: cty::c_int,
        s: size_t,
        gclusters: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn ncplane_putnstr_aligned(
        n: *mut ncplane,
        y: cty::c_int,
        align: ncalign_e,
        s: size_t,
        gclustarr: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn ncplane_putwstr_stained(n: *mut ncplane, gclustarr: *const wchar_t) -> cty::c_int;
}
extern "C" {
    #[doc = " The ncplane equivalents of printf(3) and vprintf(3)."]
    pub fn ncplane_vprintf_aligned(
        n: *mut ncplane,
        y: cty::c_int,
        align: ncalign_e,
        format: *const cty::c_char,
        ap: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    pub fn ncplane_vprintf_yx(
        n: *mut ncplane,
        y: cty::c_int,
        x: cty::c_int,
        format: *const cty::c_char,
        ap: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    pub fn ncplane_vprintf_stained(
        n: *mut ncplane,
        format: *const cty::c_char,
        ap: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Write the specified text to the plane, breaking lines sensibly, beginning at"]
    #[doc = " the specified line. Returns the number of columns written. When breaking a"]
    #[doc = " line, the line will be cleared to the end of the plane (the last line will"]
    #[doc = " *not* be so cleared). The number of bytes written from the input is written"]
    #[doc = " to '*bytes' if it is not NULL. Cleared columns are included in the return"]
    #[doc = " value, but *not* included in the number of bytes written. Leaves the cursor"]
    #[doc = " at the end of output. A partial write will be accomplished as far as it can;"]
    #[doc = " determine whether the write completed by inspecting '*bytes'. Can output to"]
    #[doc = " multiple rows even in the absence of scrolling, but not more rows than are"]
    #[doc = " available. With scrolling enabled, arbitrary amounts of data can be emitted."]
    #[doc = " All provided whitespace is preserved -- ncplane_puttext() followed by an"]
    #[doc = " appropriate ncplane_contents() will read back the original output."]
    #[doc = ""]
    #[doc = " If 'y' is -1, the first row of output is taken relative to the current"]
    #[doc = " cursor: it will be left-, right-, or center-aligned in whatever remains"]
    #[doc = " of the row. On subsequent rows -- or if 'y' is not -1 -- the entire row can"]
    #[doc = " be used, and alignment works normally."]
    #[doc = ""]
    #[doc = " A newline at any point will move the cursor to the next row."]
    pub fn ncplane_puttext(
        n: *mut ncplane,
        y: cty::c_int,
        align: ncalign_e,
        text: *const cty::c_char,
        bytes: *mut size_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Draw horizontal or vertical lines using the specified cell, starting at the"]
    #[doc = " current cursor position. The cursor will end at the cell following the last"]
    #[doc = " cell output (even, perhaps counter-intuitively, when drawing vertical"]
    #[doc = " lines), just as if ncplane_putc() was called at that spot. Return the"]
    #[doc = " number of cells drawn on success. On error, return the negative number of"]
    #[doc = " cells drawn."]
    pub fn ncplane_hline_interp(
        n: *mut ncplane,
        c: *const nccell,
        len: cty::c_int,
        c1: u64,
        c2: u64,
    ) -> cty::c_int;
}
extern "C" {
    pub fn ncplane_vline_interp(
        n: *mut ncplane,
        c: *const nccell,
        len: cty::c_int,
        c1: u64,
        c2: u64,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Draw a box with its upper-left corner at the current cursor position, and its"]
    #[doc = " lower-right corner at 'ystop'x'xstop'. The 6 cells provided are used to draw the"]
    #[doc = " upper-left, ur, ll, and lr corners, then the horizontal and vertical lines."]
    #[doc = " 'ctlword' is defined in the least significant byte, where bits [7, 4] are a"]
    #[doc = " gradient mask, and [3, 0] are a border mask:"]
    #[doc = "  * 7, 3: top"]
    #[doc = "  * 6, 2: right"]
    #[doc = "  * 5, 1: bottom"]
    #[doc = "  * 4, 0: left"]
    #[doc = " If the gradient bit is not set, the styling from the hl/vl cells is used for"]
    #[doc = " the horizontal and vertical lines, respectively. If the gradient bit is set,"]
    #[doc = " the color is linearly interpolated between the two relevant corner cells."]
    #[doc = ""]
    #[doc = " By default, vertexes are drawn whether their connecting edges are drawn or"]
    #[doc = " not. The value of the bits corresponding to NCBOXCORNER_MASK control this,"]
    #[doc = " and are interpreted as the number of connecting edges necessary to draw a"]
    #[doc = " given corner. At 0 (the default), corners are always drawn. At 3, corners"]
    #[doc = " are never drawn (since at most 2 edges can touch a box's corner)."]
    pub fn ncplane_box(
        n: *mut ncplane,
        ul: *const nccell,
        ur: *const nccell,
        ll: *const nccell,
        lr: *const nccell,
        hline: *const nccell,
        vline: *const nccell,
        ystop: cty::c_int,
        xstop: cty::c_int,
        ctlword: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Starting at the specified coordinate, if its glyph is different from that of"]
    #[doc = " 'c', 'c' is copied into it, and the original glyph is considered the fill"]
    #[doc = " target. We do the same to all cardinally-connected cells having this same"]
    #[doc = " fill target. Returns the number of cells polyfilled. An invalid initial y, x"]
    #[doc = " is an error. Returns the number of cells filled, or -1 on error."]
    pub fn ncplane_polyfill_yx(
        n: *mut ncplane,
        y: cty::c_int,
        x: cty::c_int,
        c: *const nccell,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Draw a gradient with its upper-left corner at the current cursor position,"]
    #[doc = " stopping at 'ystop'x'xstop'. The glyph composed of 'egc' and 'stylemask' is"]
    #[doc = " used for all cells. The channels specified by 'ul', 'ur', 'll', and 'lr'"]
    #[doc = " are composed into foreground and background gradients. To do a vertical"]
    #[doc = " gradient, 'ul' ought equal 'ur' and 'll' ought equal 'lr'. To do a"]
    #[doc = " horizontal gradient, 'ul' ought equal 'll' and 'ur' ought equal 'ul'. To"]
    #[doc = " color everything the same, all four channels should be equivalent. The"]
    #[doc = " resulting alpha values are equal to incoming alpha values. Returns the"]
    #[doc = " number of cells filled on success, or -1 on failure."]
    #[doc = ""]
    #[doc = " Palette-indexed color is not supported."]
    #[doc = ""]
    #[doc = " Preconditions for gradient operations (error otherwise):"]
    #[doc = ""]
    #[doc = "  all: only RGB colors, unless all four channels match as default"]
    #[doc = "  all: all alpha values must be the same"]
    #[doc = "  1x1: all four colors must be the same"]
    #[doc = "  1xN: both top and both bottom colors must be the same (vertical gradient)"]
    #[doc = "  Nx1: both left and both right colors must be the same (horizontal gradient)"]
    pub fn ncplane_gradient(
        n: *mut ncplane,
        egc: *const cty::c_char,
        stylemask: u32,
        ul: u64,
        ur: u64,
        ll: u64,
        lr: u64,
        ystop: cty::c_int,
        xstop: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Do a high-resolution gradient using upper blocks and synced backgrounds."]
    #[doc = " This doubles the number of vertical gradations, but restricts you to"]
    #[doc = " half blocks (appearing to be full blocks). Returns the number of cells"]
    #[doc = " filled on success, or -1 on error."]
    pub fn ncplane_highgradient(
        n: *mut ncplane,
        ul: u32,
        ur: u32,
        ll: u32,
        lr: u32,
        ystop: cty::c_int,
        xstop: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " ncplane_gradent_sized() meets ncplane_highgradient()."]
    pub fn ncplane_highgradient_sized(
        n: *mut ncplane,
        ul: u32,
        ur: u32,
        ll: u32,
        lr: u32,
        ylen: cty::c_int,
        xlen: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Set the given style throughout the specified region, keeping content and"]
    #[doc = " channels unchanged. Returns the number of cells set, or -1 on failure."]
    pub fn ncplane_format(
        n: *mut ncplane,
        ystop: cty::c_int,
        xstop: cty::c_int,
        stylemask: u32,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Set the given channels throughout the specified region, keeping content and"]
    #[doc = " attributes unchanged. Returns the number of cells set, or -1 on failure."]
    pub fn ncplane_stain(
        n: *mut ncplane,
        ystop: cty::c_int,
        xstop: cty::c_int,
        ul: u64,
        ur: u64,
        ll: u64,
        lr: u64,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Merge the entirety of 'src' down onto the ncplane 'dst'. If 'src' does not"]
    #[doc = " intersect with 'dst', 'dst' will not be changed, but it is not an error."]
    pub fn ncplane_mergedown_simple(src: *mut ncplane, dst: *mut ncplane) -> cty::c_int;
}
extern "C" {
    #[doc = " Merge the ncplane 'src' down onto the ncplane 'dst'. This is most rigorously"]
    #[doc = " defined as \"write to 'dst' the frame that would be rendered were the entire"]
    #[doc = " stack made up only of the specified subregion of 'src' and, below it, the"]
    #[doc = " subregion of 'dst' having the specified origin. Merging is independent of"]
    #[doc = " the position of 'src' viz 'dst' on the z-axis. It is an error to define a"]
    #[doc = " subregion of zero area, or that is not entirely contained within 'src'. It"]
    #[doc = " is an error to define a target origin such that the projected subregion is"]
    #[doc = " not entirely contained within 'dst'.  Behavior is undefined if 'src' and"]
    #[doc = " 'dst' are equivalent. 'dst' is modified, but 'src' remains unchanged."]
    #[doc = " neither 'src' nor 'dst' may have sprixels."]
    pub fn ncplane_mergedown(
        src: *mut ncplane,
        dst: *mut ncplane,
        begsrcy: cty::c_int,
        begsrcx: cty::c_int,
        leny: cty::c_int,
        lenx: cty::c_int,
        dsty: cty::c_int,
        dstx: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Erase every cell in the ncplane (each cell is initialized to the null glyph"]
    #[doc = " and the default channels/styles). All cells associated with this ncplane are"]
    #[doc = " invalidated, and must not be used after the call, *excluding* the base cell."]
    #[doc = " The cursor is homed. The plane's active attributes are unaffected."]
    pub fn ncplane_erase(n: *mut ncplane);
}
extern "C" {
    #[doc = " Erase every cell in the region starting at {ystart, xstart} and having size"]
    #[doc = " {ylen, xlen}. It is an error if any of ystart, xstart, ylen, or xlen is"]
    #[doc = " negative. A value of 0 may be provided for ylen and/or xlen, meaning to"]
    #[doc = " erase everything along that dimension. It is an error if ystart + ylen"]
    #[doc = " or xstart + xlen is not in the plane."]
    pub fn ncplane_erase_region(
        n: *mut ncplane,
        ystart: cty::c_int,
        xstart: cty::c_int,
        ylen: cty::c_int,
        xlen: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn ncplane_set_channels(n: *mut ncplane, channels: u64);
}
extern "C" {
    #[doc = " Set the specified style bits for the ncplane 'n', whether they're actively"]
    #[doc = " supported or not."]
    pub fn ncplane_set_styles(n: *mut ncplane, stylebits: cty::c_uint);
}
extern "C" {
    #[doc = " Add the specified styles to the ncplane's existing spec."]
    pub fn ncplane_on_styles(n: *mut ncplane, stylebits: cty::c_uint);
}
extern "C" {
    #[doc = " Remove the specified styles from the ncplane's existing spec."]
    pub fn ncplane_off_styles(n: *mut ncplane, stylebits: cty::c_uint);
}
extern "C" {
    #[doc = " Set an entire 32-bit channel of the plane"]
    pub fn ncplane_set_fchannel(n: *mut ncplane, channel: u32) -> u64;
}
extern "C" {
    pub fn ncplane_set_bchannel(n: *mut ncplane, channel: u32) -> u64;
}
extern "C" {
    #[doc = " Set the current fore/background color using RGB specifications. If the"]
    #[doc = " terminal does not support directly-specified 3x8b cells (24-bit \"TrueColor\","]
    #[doc = " indicated by the \"RGB\" terminfo capability), the provided values will be"]
    #[doc = " interpreted in some lossy fashion. None of r, g, or b may exceed 255."]
    #[doc = " \"HP-like\" terminals require setting foreground and background at the same"]
    #[doc = " time using \"color pairs\"; Notcurses will manage color pairs transparently."]
    pub fn ncplane_set_fg_rgb8(
        n: *mut ncplane,
        r: cty::c_int,
        g: cty::c_int,
        b: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn ncplane_set_bg_rgb8(
        n: *mut ncplane,
        r: cty::c_int,
        g: cty::c_int,
        b: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Same, but clipped to [0..255]."]
    pub fn ncplane_set_bg_rgb8_clipped(
        n: *mut ncplane,
        r: cty::c_int,
        g: cty::c_int,
        b: cty::c_int,
    );
}
extern "C" {
    pub fn ncplane_set_fg_rgb8_clipped(
        n: *mut ncplane,
        r: cty::c_int,
        g: cty::c_int,
        b: cty::c_int,
    );
}
extern "C" {
    #[doc = " Same, but with rgb assembled into a channel (i.e. lower 24 bits)."]
    pub fn ncplane_set_fg_rgb(n: *mut ncplane, channel: u32) -> cty::c_int;
}
extern "C" {
    pub fn ncplane_set_bg_rgb(n: *mut ncplane, channel: u32) -> cty::c_int;
}
extern "C" {
    #[doc = " Use the default color for the foreground/background."]
    pub fn ncplane_set_fg_default(n: *mut ncplane);
}
extern "C" {
    pub fn ncplane_set_bg_default(n: *mut ncplane);
}
extern "C" {
    #[doc = " Set the ncplane's foreground palette index, set the foreground palette index"]
    #[doc = " bit, set it foreground-opaque, and clear the foreground default color bit."]
    pub fn ncplane_set_fg_palindex(n: *mut ncplane, idx: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ncplane_set_bg_palindex(n: *mut ncplane, idx: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Set the alpha parameters for ncplane 'n'."]
    pub fn ncplane_set_fg_alpha(n: *mut ncplane, alpha: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ncplane_set_bg_alpha(n: *mut ncplane, alpha: cty::c_int) -> cty::c_int;
}
#[doc = " Called for each fade iteration on 'ncp'. If anything but 0 is returned,"]
#[doc = " the fading operation ceases immediately, and that value is propagated out."]
#[doc = " The recommended absolute display time target is passed in 'tspec'."]
pub type fadecb = ::core::option::Option<
    unsafe extern "C" fn(
        nc: *mut notcurses,
        n: *mut ncplane,
        arg1: *const timespec,
        curry: *mut cty::c_void,
    ) -> cty::c_int,
>;
extern "C" {
    #[doc = " Fade the ncplane out over the provided time, calling 'fader' at each"]
    #[doc = " iteration. Requires a terminal which supports truecolor, or at least palette"]
    #[doc = " modification (if the terminal uses a palette, our ability to fade planes is"]
    #[doc = " limited, and affected by the complexity of the rest of the screen)."]
    pub fn ncplane_fadeout(
        n: *mut ncplane,
        ts: *const timespec,
        fader: fadecb,
        curry: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Fade the ncplane in over the specified time. Load the ncplane with the"]
    #[doc = " target cells without rendering, then call this function. When it's done, the"]
    #[doc = " ncplane will have reached the target levels, starting from zeroes."]
    pub fn ncplane_fadein(
        n: *mut ncplane,
        ts: *const timespec,
        fader: fadecb,
        curry: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Rather than the simple ncplane_fade{in/out}(), ncfadectx_setup() can be"]
    #[doc = " paired with a loop over ncplane_fade{in/out}_iteration() + ncfadectx_free()."]
    pub fn ncfadectx_setup(n: *mut ncplane) -> *mut ncfadectx;
}
extern "C" {
    #[doc = " Return the number of iterations through which 'nctx' will fade."]
    pub fn ncfadectx_iterations(nctx: *const ncfadectx) -> cty::c_int;
}
extern "C" {
    #[doc = " Fade out through 'iter' iterations, where"]
    #[doc = " 'iter' < 'ncfadectx_iterations(nctx)'."]
    pub fn ncplane_fadeout_iteration(
        n: *mut ncplane,
        nctx: *mut ncfadectx,
        iter: cty::c_int,
        fader: fadecb,
        curry: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Fade in through 'iter' iterations, where"]
    #[doc = " 'iter' < 'ncfadectx_iterations(nctx)'."]
    pub fn ncplane_fadein_iteration(
        n: *mut ncplane,
        nctx: *mut ncfadectx,
        iter: cty::c_int,
        fader: fadecb,
        curry: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Pulse the plane in and out until the callback returns non-zero, relying on"]
    #[doc = " the callback 'fader' to initiate rendering. 'ts' defines the half-period"]
    #[doc = " (i.e. the transition from black to full brightness, or back again). Proper"]
    #[doc = " use involves preparing (but not rendering) an ncplane, then calling"]
    #[doc = " ncplane_pulse(), which will fade in from black to the specified colors."]
    pub fn ncplane_pulse(
        n: *mut ncplane,
        ts: *const timespec,
        fader: fadecb,
        curry: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Release the resources associated with 'nctx'."]
    pub fn ncfadectx_free(nctx: *mut ncfadectx);
}
extern "C" {
    pub fn nccells_rounded_box(
        n: *mut ncplane,
        styles: u32,
        channels: u64,
        ul: *mut nccell,
        ur: *mut nccell,
        ll: *mut nccell,
        lr: *mut nccell,
        hl: *mut nccell,
        vl: *mut nccell,
    ) -> cty::c_int;
}
extern "C" {
    pub fn nccells_double_box(
        n: *mut ncplane,
        styles: u32,
        channels: u64,
        ul: *mut nccell,
        ur: *mut nccell,
        ll: *mut nccell,
        lr: *mut nccell,
        hl: *mut nccell,
        vl: *mut nccell,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Open a visual at 'file', extract a codec and parameters, decode the first"]
    #[doc = " image to memory."]
    pub fn ncvisual_from_file(file: *const cty::c_char) -> *mut ncvisual;
}
extern "C" {
    #[doc = " Prepare an ncvisual, and its underlying plane, based off RGBA content in"]
    #[doc = " memory at 'rgba'. 'rgba' is laid out as 'rows' lines, each of which is"]
    #[doc = " 'rowstride' bytes in length. Each line has 'cols' 32-bit 8bpc RGBA pixels"]
    #[doc = " followed by possible padding (there will be 'rowstride' - 'cols' * 4 bytes"]
    #[doc = " of padding). The total size of 'rgba' is thus (rows * rowstride) bytes, of"]
    #[doc = " which (rows * cols * 4) bytes are actual non-padding data."]
    pub fn ncvisual_from_rgba(
        rgba: *const cty::c_void,
        rows: cty::c_int,
        rowstride: cty::c_int,
        cols: cty::c_int,
    ) -> *mut ncvisual;
}
extern "C" {
    #[doc = " ncvisual_from_rgba(), but the pixels are 3-byte RGB. A is filled in"]
    #[doc = " throughout using 'alpha'."]
    pub fn ncvisual_from_rgb_packed(
        rgba: *const cty::c_void,
        rows: cty::c_int,
        rowstride: cty::c_int,
        cols: cty::c_int,
        alpha: cty::c_int,
    ) -> *mut ncvisual;
}
extern "C" {
    #[doc = " ncvisual_from_rgba(), but the pixels are 4-byte RGBx. A is filled in"]
    #[doc = " throughout using 'alpha'. rowstride must be a multiple of 4."]
    pub fn ncvisual_from_rgb_loose(
        rgba: *const cty::c_void,
        rows: cty::c_int,
        rowstride: cty::c_int,
        cols: cty::c_int,
        alpha: cty::c_int,
    ) -> *mut ncvisual;
}
extern "C" {
    #[doc = " ncvisual_from_rgba(), but 'bgra' is arranged as BGRA. note that this is a"]
    #[doc = " byte-oriented layout, despite being bunched in 32-bit pixels; the lowest"]
    #[doc = " memory address ought be B, and A is reached by adding 3 to that address."]
    pub fn ncvisual_from_bgra(
        bgra: *const cty::c_void,
        rows: cty::c_int,
        rowstride: cty::c_int,
        cols: cty::c_int,
    ) -> *mut ncvisual;
}
extern "C" {
    #[doc = " Promote an ncplane 'n' to an ncvisual. The plane may contain only spaces,"]
    #[doc = " half blocks, and full blocks. The latter will be checked, and any other"]
    #[doc = " glyph will result in a NULL being returned. This function exists so that"]
    #[doc = " planes can be subjected to ncvisual transformations. If possible, it's"]
    #[doc = " better to create the ncvisual from memory using ncvisual_from_rgba()."]
    pub fn ncvisual_from_plane(
        n: *const ncplane,
        blit: ncblitter_e,
        begy: cty::c_int,
        begx: cty::c_int,
        leny: cty::c_int,
        lenx: cty::c_int,
    ) -> *mut ncvisual;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncvisual_options {
    #[doc = " if no ncplane is provided, one will be created using the exact size"]
    #[doc = " necessary to render the source with perfect fidelity (this might be"]
    #[doc = " smaller or larger than the rendering area). if NCVISUAL_OPTION_CHILDPLANE"]
    #[doc = " is provided, this must be non-NULL, and will be interpreted as the parent."]
    pub n: *mut ncplane,
    #[doc = " the scaling is ignored if no ncplane is provided (it ought be NCSCALE_NONE"]
    #[doc = " in this case). otherwise, the source is stretched/scaled relative to the"]
    #[doc = " provided ncplane."]
    pub scaling: ncscale_e,
    #[doc = " if an ncplane is provided, y and x specify where the visual will be"]
    #[doc = " rendered on that plane. otherwise, they specify where the created ncplane"]
    #[doc = " will be placed relative to the standard plane's origin. x is an ncalign_e"]
    #[doc = " value if NCVISUAL_OPTION_HORALIGNED is provided. y is an ncalign_e if"]
    #[doc = " NCVISUAL_OPTION_VERALIGNED is provided."]
    pub y: cty::c_int,
    #[doc = " if an ncplane is provided, y and x specify where the visual will be"]
    #[doc = " rendered on that plane. otherwise, they specify where the created ncplane"]
    #[doc = " will be placed relative to the standard plane's origin. x is an ncalign_e"]
    #[doc = " value if NCVISUAL_OPTION_HORALIGNED is provided. y is an ncalign_e if"]
    #[doc = " NCVISUAL_OPTION_VERALIGNED is provided."]
    pub x: cty::c_int,
    #[doc = " origin of rendered section"]
    pub begy: cty::c_int,
    #[doc = " origin of rendered section"]
    pub begx: cty::c_int,
    #[doc = " size of rendered section"]
    pub leny: cty::c_int,
    #[doc = " size of rendered section"]
    pub lenx: cty::c_int,
    #[doc = " glyph set to use (maps input to output cells)"]
    pub blitter: ncblitter_e,
    #[doc = " bitmask over NCVISUAL_OPTION_*"]
    pub flags: u64,
    #[doc = " treat this color as transparent under NCVISUAL_OPTION_ADDALPHA"]
    pub transcolor: u32,
}
#[test]
fn bindgen_test_layout_ncvisual_options() {
    assert_eq!(
        ::core::mem::size_of::<ncvisual_options>(),
        56usize,
        concat!("Size of: ", stringify!(ncvisual_options))
    );
    assert_eq!(
        ::core::mem::align_of::<ncvisual_options>(),
        8usize,
        concat!("Alignment of ", stringify!(ncvisual_options))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvisual_options>())).n as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvisual_options),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvisual_options>())).scaling as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvisual_options),
            "::",
            stringify!(scaling)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvisual_options>())).y as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvisual_options),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvisual_options>())).x as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvisual_options),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvisual_options>())).begy as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvisual_options),
            "::",
            stringify!(begy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvisual_options>())).begx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvisual_options),
            "::",
            stringify!(begx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvisual_options>())).leny as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvisual_options),
            "::",
            stringify!(leny)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvisual_options>())).lenx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvisual_options),
            "::",
            stringify!(lenx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvisual_options>())).blitter as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvisual_options),
            "::",
            stringify!(blitter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvisual_options>())).flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvisual_options),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvisual_options>())).transcolor as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvisual_options),
            "::",
            stringify!(transcolor)
        )
    );
}
impl Default for ncvisual_options {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Create an RGBA flat array from the selected region of the ncplane 'nc'."]
    #[doc = " Start at the plane's 'begy'x'begx' coordinate (which must lie on the"]
    #[doc = " plane), continuing for 'leny'x'lenx' cells. Either or both of 'leny' and"]
    #[doc = " 'lenx' can be specified as -1 to go through the boundary of the plane."]
    #[doc = " Only glyphs from the specified ncblitset may be present. If 'pxdimy' and/or"]
    #[doc = " 'pxdimx' are non-NULL, they will be filled in with the pixel geometry."]
    pub fn ncplane_as_rgba(
        n: *const ncplane,
        blit: ncblitter_e,
        begy: cty::c_int,
        begx: cty::c_int,
        leny: cty::c_int,
        lenx: cty::c_int,
        pxdimy: *mut cty::c_int,
        pxdimx: *mut cty::c_int,
    ) -> *mut u32;
}
extern "C" {
    #[doc = " Get the size and ratio of ncvisual pixels to output cells along the y"]
    #[doc = " and x axes. The input size (in pixels) will be written to 'y' and 'x'."]
    #[doc = " The scaling will be written to 'scaley' and 'scalex'. With these:"]
    #[doc = "  rows = (y / scaley) + !!(y % scaley) or (y + scaley - 1) / scaley"]
    #[doc = "  cols = (x / scalex) + !!(x % scalex) or (x + scalex - 1) / scalex"]
    #[doc = " Returns non-zero for an invalid 'vopts'. The blitter that will be used"]
    #[doc = " is returned in '*blitter'."]
    pub fn ncvisual_blitter_geom(
        nc: *const notcurses,
        n: *const ncvisual,
        vopts: *const ncvisual_options,
        y: *mut cty::c_int,
        x: *mut cty::c_int,
        scaley: *mut cty::c_int,
        scalex: *mut cty::c_int,
        blitter: *mut ncblitter_e,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Destroy an ncvisual. Rendered elements will not be disrupted, but the visual"]
    #[doc = " can be neither decoded nor rendered any further."]
    pub fn ncvisual_destroy(ncv: *mut ncvisual);
}
extern "C" {
    #[doc = " extract the next frame from an ncvisual. returns 1 on end of file, 0 on"]
    #[doc = " success, and -1 on failure."]
    pub fn ncvisual_decode(nc: *mut ncvisual) -> cty::c_int;
}
extern "C" {
    #[doc = " decode the next frame ala ncvisual_decode(), but if we have reached the end,"]
    #[doc = " rewind to the first frame of the ncvisual. a subsequent 'ncvisual_render()'"]
    #[doc = " will render the first frame, as if the ncvisual had been closed and reopened."]
    #[doc = " the return values remain the same as those of ncvisual_decode()."]
    pub fn ncvisual_decode_loop(nc: *mut ncvisual) -> cty::c_int;
}
extern "C" {
    #[doc = " Rotate the visual 'rads' radians. Only M_PI/2 and -M_PI/2 are"]
    #[doc = " supported at the moment, but this will change FIXME."]
    pub fn ncvisual_rotate(n: *mut ncvisual, rads: f64) -> cty::c_int;
}
extern "C" {
    #[doc = " Scale the visual to 'rows' X 'columns' pixels, using the best scheme"]
    #[doc = " available. This is a lossy transformation, unless the size is unchanged."]
    pub fn ncvisual_resize(n: *mut ncvisual, rows: cty::c_int, cols: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Scale the visual to 'rows' X 'columns' pixels, using non-interpolative"]
    #[doc = " (naive) scaling. No new colors will be introduced as a result."]
    pub fn ncvisual_resize_noninterpolative(
        n: *mut ncvisual,
        rows: cty::c_int,
        cols: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Polyfill at the specified location within the ncvisual 'n', using 'rgba'."]
    pub fn ncvisual_polyfill_yx(
        n: *mut ncvisual,
        y: cty::c_int,
        x: cty::c_int,
        rgba: u32,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Get the specified pixel from the specified ncvisual."]
    pub fn ncvisual_at_yx(
        n: *const ncvisual,
        y: cty::c_int,
        x: cty::c_int,
        pixel: *mut u32,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Set the specified pixel in the specified ncvisual."]
    pub fn ncvisual_set_yx(
        n: *const ncvisual,
        y: cty::c_int,
        x: cty::c_int,
        pixel: u32,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Render the decoded frame to the specified ncplane. If one is not provided,"]
    #[doc = " one will be created, having the exact size necessary to display the visual."]
    #[doc = " A subregion of the visual can be rendered using 'begx', 'begy', 'lenx', and"]
    #[doc = " 'leny'. Negative values for 'begy' or 'begx' are an error. It is an error to"]
    #[doc = " specify any region beyond the boundaries of the frame. Returns the"]
    #[doc = " (possibly newly-created) plane to which we drew."]
    pub fn ncvisual_render(
        nc: *mut notcurses,
        ncv: *mut ncvisual,
        vopts: *const ncvisual_options,
    ) -> *mut ncplane;
}
extern "C" {
    #[doc = " If a subtitle ought be displayed at this time, return a heap-allocated copy"]
    #[doc = " of the UTF8 text."]
    pub fn ncvisual_subtitle(ncv: *const ncvisual) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " Get the default *media* (not plot) blitter for this environment when using"]
    #[doc = " the specified scaling method. Currently, this means:"]
    #[doc = "  - if lacking UTF-8, NCBLIT_1x1"]
    #[doc = "  - otherwise, if not NCSCALE_STRETCH, NCBLIT_2x1"]
    #[doc = "  - otherwise, if sextants are not known to be good, NCBLIT_2x2"]
    #[doc = "  - otherwise NCBLIT_3x2"]
    #[doc = " NCBLIT_2x2 and NCBLIT_3x2 both distort the original aspect ratio, thus"]
    #[doc = " NCBLIT_2x1 is used outside of NCSCALE_STRETCH."]
    pub fn ncvisual_media_defblitter(nc: *const notcurses, scale: ncscale_e) -> ncblitter_e;
}
#[doc = " Called for each frame rendered from 'ncv'. If anything but 0 is returned,"]
#[doc = " the streaming operation ceases immediately, and that value is propagated out."]
#[doc = " The recommended absolute display time target is passed in 'tspec'."]
pub type ncstreamcb = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ncvisual,
        arg2: *mut ncvisual_options,
        arg3: *const timespec,
        arg4: *mut cty::c_void,
    ) -> cty::c_int,
>;
extern "C" {
    #[doc = " Shut up and display my frames! Provide as an argument to ncvisual_stream()."]
    #[doc = " If you'd like subtitles to be decoded, provide an ncplane as the curry. If the"]
    #[doc = " curry is NULL, subtitles will not be displayed."]
    pub fn ncvisual_simple_streamer(
        ncv: *mut ncvisual,
        vopts: *mut ncvisual_options,
        tspec: *const timespec,
        curry: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Stream the entirety of the media, according to its own timing. Blocking,"]
    #[doc = " obviously. streamer may be NULL; it is otherwise called for each frame, and"]
    #[doc = " its return value handled as outlined for streamcb. If streamer() returns"]
    #[doc = " non-zero, the stream is aborted, and that value is returned. By convention,"]
    #[doc = " return a positive number to indicate intentional abort from within"]
    #[doc = " streamer(). 'timescale' allows the frame duration time to be scaled. For a"]
    #[doc = " visual naturally running at 30FPS, a 'timescale' of 0.1 will result in"]
    #[doc = " 300FPS, and a 'timescale' of 10 will result in 3FPS. It is an error to"]
    #[doc = " supply 'timescale' less than or equal to 0."]
    pub fn ncvisual_stream(
        nc: *mut notcurses,
        ncv: *mut ncvisual,
        timescale: f32,
        streamer: ncstreamcb,
        vopts: *const ncvisual_options,
        curry: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Blit a flat array 'data' of RGBA 32-bit values to the ncplane 'vopts->n',"]
    #[doc = " which mustn't be NULL. the blit begins at 'vopts->y' and 'vopts->x' relative"]
    #[doc = " to the specified plane. Each source row ought occupy 'linesize' bytes (this"]
    #[doc = " might be greater than 'vopts->lenx' * 4 due to padding or partial blits). A"]
    #[doc = " subregion of the input can be specified with the 'begy'x'begx' and"]
    #[doc = " 'leny'x'lenx' fields from 'vopts'. Returns the number of pixels blitted, or"]
    #[doc = " -1 on error."]
    pub fn ncblit_rgba(
        data: *const cty::c_void,
        linesize: cty::c_int,
        vopts: *const ncvisual_options,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Same as ncblit_rgba(), but for BGRx."]
    pub fn ncblit_bgrx(
        data: *const cty::c_void,
        linesize: cty::c_int,
        vopts: *const ncvisual_options,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Supply an alpha value [0..255] to be applied throughout."]
    pub fn ncblit_rgb_packed(
        data: *const cty::c_void,
        linesize: cty::c_int,
        vopts: *const ncvisual_options,
        alpha: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Supply an alpha value [0..255] to be applied throughout. linesize must be"]
    #[doc = " a multiple of 4 for this RGBx data."]
    pub fn ncblit_rgb_loose(
        data: *const cty::c_void,
        linesize: cty::c_int,
        vopts: *const ncvisual_options,
        alpha: cty::c_int,
    ) -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncreel_options {
    #[doc = " bitfield; 1s will not be drawn (see bordermaskbits)"]
    pub bordermask: cty::c_uint,
    #[doc = " attributes used for ncreel border"]
    pub borderchan: u64,
    #[doc = " bitfield; same as bordermask but for tablet borders"]
    pub tabletmask: cty::c_uint,
    #[doc = " tablet border styling channel"]
    pub tabletchan: u64,
    #[doc = " focused tablet border styling channel"]
    pub focusedchan: u64,
    #[doc = " bitfield over NCREEL_OPTION_*"]
    pub flags: u64,
}
#[test]
fn bindgen_test_layout_ncreel_options() {
    assert_eq!(
        ::core::mem::size_of::<ncreel_options>(),
        48usize,
        concat!("Size of: ", stringify!(ncreel_options))
    );
    assert_eq!(
        ::core::mem::align_of::<ncreel_options>(),
        8usize,
        concat!("Alignment of ", stringify!(ncreel_options))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncreel_options>())).bordermask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncreel_options),
            "::",
            stringify!(bordermask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncreel_options>())).borderchan as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncreel_options),
            "::",
            stringify!(borderchan)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncreel_options>())).tabletmask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncreel_options),
            "::",
            stringify!(tabletmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncreel_options>())).tabletchan as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ncreel_options),
            "::",
            stringify!(tabletchan)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncreel_options>())).focusedchan as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ncreel_options),
            "::",
            stringify!(focusedchan)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncreel_options>())).flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ncreel_options),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = " Take over the ncplane 'nc' and use it to draw a reel according to 'popts'."]
    #[doc = " The plane will be destroyed by ncreel_destroy(); this transfers ownership."]
    pub fn ncreel_create(n: *mut ncplane, popts: *const ncreel_options) -> *mut ncreel;
}
extern "C" {
    #[doc = " Returns the ncplane on which this ncreel lives."]
    pub fn ncreel_plane(nr: *mut ncreel) -> *mut ncplane;
}
#[doc = " Tablet draw callback, provided a tablet (from which the ncplane and userptr"]
#[doc = " may be extracted), and a bool indicating whether output ought be drawn from"]
#[doc = " the top (true) or bottom (false). Returns non-negative count of output lines,"]
#[doc = " which must be less than or equal to ncplane_dim_y(nctablet_plane(t))."]
pub type tabletcb =
    ::core::option::Option<unsafe extern "C" fn(t: *mut nctablet, drawfromtop: bool) -> cty::c_int>;
extern "C" {
    #[doc = " Add a new nctablet to the provided ncreel 'nr', having the callback object"]
    #[doc = " 'opaque'. Neither, either, or both of 'after' and 'before' may be specified."]
    #[doc = " If neither is specified, the new tablet can be added anywhere on the reel."]
    #[doc = " If one or the other is specified, the tablet will be added before or after"]
    #[doc = " the specified tablet. If both are specified, the tablet will be added to the"]
    #[doc = " resulting location, assuming it is valid (after->next == before->prev); if"]
    #[doc = " it is not valid, or there is any other error, NULL will be returned."]
    pub fn ncreel_add(
        nr: *mut ncreel,
        after: *mut nctablet,
        before: *mut nctablet,
        cb: tabletcb,
        opaque: *mut cty::c_void,
    ) -> *mut nctablet;
}
extern "C" {
    #[doc = " Return the number of nctablets in the ncreel 'nr'."]
    pub fn ncreel_tabletcount(nr: *const ncreel) -> cty::c_int;
}
extern "C" {
    #[doc = " Delete the tablet specified by t from the ncreel 'nr'. Returns -1 if the"]
    #[doc = " tablet cannot be found."]
    pub fn ncreel_del(nr: *mut ncreel, t: *mut nctablet) -> cty::c_int;
}
extern "C" {
    #[doc = " Redraw the ncreel 'nr' in its entirety. The reel will be cleared, and"]
    #[doc = " tablets will be lain out, using the focused tablet as a fulcrum. Tablet"]
    #[doc = " drawing callbacks will be invoked for each visible tablet."]
    pub fn ncreel_redraw(nr: *mut ncreel) -> cty::c_int;
}
extern "C" {
    #[doc = " Offer input 'ni' to the ncreel 'nr'. If it's relevant, this function returns"]
    #[doc = " true, and the input ought not be processed further. If it's irrelevant to"]
    #[doc = " the reel, false is returned. Relevant inputs include:"]
    #[doc = "  * a mouse click on a tablet (focuses tablet)"]
    #[doc = "  * a mouse scrollwheel event (rolls reel)"]
    #[doc = "  * up, down, pgup, or pgdown (navigates among items)"]
    pub fn ncreel_offer_input(nr: *mut ncreel, ni: *const ncinput) -> bool;
}
extern "C" {
    #[doc = " Return the focused tablet, if any tablets are present. This is not a copy;"]
    #[doc = " be careful to use it only for the duration of a critical section."]
    pub fn ncreel_focused(nr: *mut ncreel) -> *mut nctablet;
}
extern "C" {
    #[doc = " Change focus to the next tablet, if one exists"]
    pub fn ncreel_next(nr: *mut ncreel) -> *mut nctablet;
}
extern "C" {
    #[doc = " Change focus to the previous tablet, if one exists"]
    pub fn ncreel_prev(nr: *mut ncreel) -> *mut nctablet;
}
extern "C" {
    #[doc = " Destroy an ncreel allocated with ncreel_create()."]
    pub fn ncreel_destroy(nr: *mut ncreel);
}
extern "C" {
    #[doc = " Returns a pointer to a user pointer associated with this nctablet."]
    pub fn nctablet_userptr(t: *mut nctablet) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Access the ncplane associated with nctablet 't', if one exists."]
    pub fn nctablet_plane(t: *mut nctablet) -> *mut ncplane;
}
extern "C" {
    #[doc = " Floating-point is never used, because an IEEE758 double can only losslessly"]
    #[doc = " represent integers through 2^53-1."]
    #[doc = ""]
    #[doc = " 2^64-1 is 18446744073709551615, 18.45E(xa). KMGTPEZY thus suffice to handle"]
    #[doc = " an 89-bit uintmax_t. Beyond Z(etta) and Y(otta) lie lands unspecified by SI."]
    #[doc = " 2^-63 is 0.000000000000000000108, 1.08a(tto)."]
    #[doc = " val: value to print"]
    #[doc = " decimal: scaling. '1' if none has taken place."]
    #[doc = " buf: buffer in which string will be generated"]
    #[doc = " omitdec: inhibit printing of all-0 decimal portions"]
    #[doc = " mult: base of suffix system (almost always 1000 or 1024)"]
    #[doc = " uprefix: character to print following suffix ('i' for kibibytes basically)."]
    #[doc = "   only printed if suffix is actually printed (input >= mult)."]
    #[doc = ""]
    #[doc = " You are encouraged to consult notcurses_metric(3)."]
    pub fn ncmetric(
        val: uintmax_t,
        decimal: uintmax_t,
        buf: *mut cty::c_char,
        omitdec: cty::c_int,
        mult: uintmax_t,
        uprefix: cty::c_int,
    ) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Enable or disable the terminal's cursor, if supported, placing it at"]
    #[doc = " 'y', 'x'. Immediate effect (no need for a call to notcurses_render())."]
    #[doc = " It is an error if 'y', 'x' lies outside the standard plane. Can be"]
    #[doc = " called while already visible to move the cursor."]
    pub fn notcurses_cursor_enable(nc: *mut notcurses, y: cty::c_int, x: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Get the current location of the terminal's cursor, whether visible or not."]
    pub fn notcurses_cursor_yx(
        nc: *mut notcurses,
        y: *mut cty::c_int,
        x: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Disable the hardware cursor. It is an error to call this while the"]
    #[doc = " cursor is already disabled."]
    pub fn notcurses_cursor_disable(nc: *mut notcurses) -> cty::c_int;
}
extern "C" {
    #[doc = " Convert the plane's content to greyscale."]
    pub fn ncplane_greyscale(n: *mut ncplane);
}
#[doc = " selection widget -- an ncplane with a title header and a body section. the"]
#[doc = " body section supports infinite scrolling up and down."]
#[doc = ""]
#[doc = " At all times, exactly one item is selected."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncselector_item {
    pub option: *mut cty::c_char,
    pub desc: *mut cty::c_char,
    #[doc = " filled in by library"]
    pub opcolumns: size_t,
    #[doc = " filled in by library"]
    pub desccolumns: size_t,
}
#[test]
fn bindgen_test_layout_ncselector_item() {
    assert_eq!(
        ::core::mem::size_of::<ncselector_item>(),
        32usize,
        concat!("Size of: ", stringify!(ncselector_item))
    );
    assert_eq!(
        ::core::mem::align_of::<ncselector_item>(),
        8usize,
        concat!("Alignment of ", stringify!(ncselector_item))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncselector_item>())).option as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncselector_item),
            "::",
            stringify!(option)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncselector_item>())).desc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncselector_item),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncselector_item>())).opcolumns as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncselector_item),
            "::",
            stringify!(opcolumns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncselector_item>())).desccolumns as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ncselector_item),
            "::",
            stringify!(desccolumns)
        )
    );
}
impl Default for ncselector_item {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncselector_options {
    #[doc = " title may be NULL, inhibiting riser, saving two rows."]
    pub title: *mut cty::c_char,
    #[doc = " secondary may be NULL"]
    pub secondary: *mut cty::c_char,
    #[doc = " footer may be NULL"]
    pub footer: *mut cty::c_char,
    #[doc = " initial items and descriptions"]
    pub items: *mut ncselector_item,
    #[doc = " default item (selected at start), must be < itemcount unless itemcount is"]
    #[doc = " 0, in which case 'defidx' must also be 0"]
    pub defidx: cty::c_uint,
    #[doc = " maximum number of options to display at once, 0 to use all available space"]
    pub maxdisplay: cty::c_uint,
    #[doc = " option channels"]
    pub opchannels: u64,
    #[doc = " description channels"]
    pub descchannels: u64,
    #[doc = " title channels"]
    pub titlechannels: u64,
    #[doc = " secondary and footer channels"]
    pub footchannels: u64,
    #[doc = " border channels"]
    pub boxchannels: u64,
    #[doc = " bitfield of NCSELECTOR_OPTION_*"]
    pub flags: u64,
}
#[test]
fn bindgen_test_layout_ncselector_options() {
    assert_eq!(
        ::core::mem::size_of::<ncselector_options>(),
        88usize,
        concat!("Size of: ", stringify!(ncselector_options))
    );
    assert_eq!(
        ::core::mem::align_of::<ncselector_options>(),
        8usize,
        concat!("Alignment of ", stringify!(ncselector_options))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncselector_options>())).title as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncselector_options),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncselector_options>())).secondary as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncselector_options),
            "::",
            stringify!(secondary)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncselector_options>())).footer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncselector_options),
            "::",
            stringify!(footer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncselector_options>())).items as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ncselector_options),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncselector_options>())).defidx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ncselector_options),
            "::",
            stringify!(defidx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncselector_options>())).maxdisplay as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ncselector_options),
            "::",
            stringify!(maxdisplay)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncselector_options>())).opchannels as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ncselector_options),
            "::",
            stringify!(opchannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ncselector_options>())).descchannels as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ncselector_options),
            "::",
            stringify!(descchannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ncselector_options>())).titlechannels as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ncselector_options),
            "::",
            stringify!(titlechannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ncselector_options>())).footchannels as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ncselector_options),
            "::",
            stringify!(footchannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncselector_options>())).boxchannels as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ncselector_options),
            "::",
            stringify!(boxchannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncselector_options>())).flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ncselector_options),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for ncselector_options {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn ncselector_create(n: *mut ncplane, opts: *const ncselector_options) -> *mut ncselector;
}
extern "C" {
    #[doc = " Dynamically add or delete items. It is usually sufficient to supply a static"]
    #[doc = " list of items via ncselector_options->items."]
    pub fn ncselector_additem(n: *mut ncselector, item: *const ncselector_item) -> cty::c_int;
}
extern "C" {
    pub fn ncselector_delitem(n: *mut ncselector, item: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    #[doc = " Return reference to the selected option, or NULL if there are no items."]
    pub fn ncselector_selected(n: *const ncselector) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Return a reference to the ncselector's underlying ncplane."]
    pub fn ncselector_plane(n: *mut ncselector) -> *mut ncplane;
}
extern "C" {
    #[doc = " Move up or down in the list. A reference to the newly-selected item is"]
    #[doc = " returned, or NULL if there are no items in the list."]
    pub fn ncselector_previtem(n: *mut ncselector) -> *const cty::c_char;
}
extern "C" {
    pub fn ncselector_nextitem(n: *mut ncselector) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Offer the input to the ncselector. If it's relevant, this function returns"]
    #[doc = " true, and the input ought not be processed further. If it's irrelevant to"]
    #[doc = " the selector, false is returned. Relevant inputs include:"]
    #[doc = "  * a mouse click on an item"]
    #[doc = "  * a mouse scrollwheel event"]
    #[doc = "  * a mouse click on the scrolling arrows"]
    #[doc = "  * up, down, pgup, or pgdown on an unrolled menu (navigates among items)"]
    pub fn ncselector_offer_input(n: *mut ncselector, nc: *const ncinput) -> bool;
}
extern "C" {
    #[doc = " Destroy the ncselector. If 'item' is not NULL, the last selected option will"]
    #[doc = " be strdup()ed and assigned to '*item' (and must be free()d by the caller)."]
    pub fn ncselector_destroy(n: *mut ncselector, item: *mut *mut cty::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncmselector_item {
    pub option: *mut cty::c_char,
    pub desc: *mut cty::c_char,
    pub selected: bool,
}
#[test]
fn bindgen_test_layout_ncmselector_item() {
    assert_eq!(
        ::core::mem::size_of::<ncmselector_item>(),
        24usize,
        concat!("Size of: ", stringify!(ncmselector_item))
    );
    assert_eq!(
        ::core::mem::align_of::<ncmselector_item>(),
        8usize,
        concat!("Alignment of ", stringify!(ncmselector_item))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmselector_item>())).option as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmselector_item),
            "::",
            stringify!(option)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmselector_item>())).desc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmselector_item),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmselector_item>())).selected as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmselector_item),
            "::",
            stringify!(selected)
        )
    );
}
impl Default for ncmselector_item {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " multiselection widget -- a selector supporting multiple selections."]
#[doc = ""]
#[doc = " Unlike the selector widget, zero to all of the items can be selected, but"]
#[doc = " also the widget does not support adding or removing items at runtime."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncmultiselector_options {
    #[doc = " title may be NULL, inhibiting riser, saving two rows."]
    pub title: *mut cty::c_char,
    #[doc = " secondary may be NULL"]
    pub secondary: *mut cty::c_char,
    #[doc = " footer may be NULL"]
    pub footer: *mut cty::c_char,
    #[doc = " initial items, descriptions, and statuses"]
    pub items: *mut ncmselector_item,
    #[doc = " maximum number of options to display at once, 0 to use all available space"]
    pub maxdisplay: cty::c_uint,
    #[doc = " option channels"]
    pub opchannels: u64,
    #[doc = " description channels"]
    pub descchannels: u64,
    #[doc = " title channels"]
    pub titlechannels: u64,
    #[doc = " secondary and footer channels"]
    pub footchannels: u64,
    #[doc = " border channels"]
    pub boxchannels: u64,
    #[doc = " bitfield of NCMULTISELECTOR_OPTION_*"]
    pub flags: u64,
}
#[test]
fn bindgen_test_layout_ncmultiselector_options() {
    assert_eq!(
        ::core::mem::size_of::<ncmultiselector_options>(),
        88usize,
        concat!("Size of: ", stringify!(ncmultiselector_options))
    );
    assert_eq!(
        ::core::mem::align_of::<ncmultiselector_options>(),
        8usize,
        concat!("Alignment of ", stringify!(ncmultiselector_options))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmultiselector_options>())).title as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmultiselector_options),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ncmultiselector_options>())).secondary as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmultiselector_options),
            "::",
            stringify!(secondary)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmultiselector_options>())).footer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmultiselector_options),
            "::",
            stringify!(footer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmultiselector_options>())).items as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmultiselector_options),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ncmultiselector_options>())).maxdisplay as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmultiselector_options),
            "::",
            stringify!(maxdisplay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ncmultiselector_options>())).opchannels as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmultiselector_options),
            "::",
            stringify!(opchannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ncmultiselector_options>())).descchannels as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmultiselector_options),
            "::",
            stringify!(descchannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ncmultiselector_options>())).titlechannels as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmultiselector_options),
            "::",
            stringify!(titlechannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ncmultiselector_options>())).footchannels as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmultiselector_options),
            "::",
            stringify!(footchannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ncmultiselector_options>())).boxchannels as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmultiselector_options),
            "::",
            stringify!(boxchannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmultiselector_options>())).flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmultiselector_options),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for ncmultiselector_options {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn ncmultiselector_create(
        n: *mut ncplane,
        opts: *const ncmultiselector_options,
    ) -> *mut ncmultiselector;
}
extern "C" {
    #[doc = " Return selected vector. An array of bools must be provided, along with its"]
    #[doc = " length. If that length doesn't match the itemcount, it is an error."]
    pub fn ncmultiselector_selected(
        n: *mut ncmultiselector,
        selected: *mut bool,
        count: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Return a reference to the ncmultiselector's underlying ncplane."]
    pub fn ncmultiselector_plane(n: *mut ncmultiselector) -> *mut ncplane;
}
extern "C" {
    #[doc = " Offer the input to the ncmultiselector. If it's relevant, this function"]
    #[doc = " returns true, and the input ought not be processed further. If it's"]
    #[doc = " irrelevant to the multiselector, false is returned. Relevant inputs include:"]
    #[doc = "  * a mouse click on an item"]
    #[doc = "  * a mouse scrollwheel event"]
    #[doc = "  * a mouse click on the scrolling arrows"]
    #[doc = "  * up, down, pgup, or pgdown on an unrolled menu (navigates among items)"]
    pub fn ncmultiselector_offer_input(n: *mut ncmultiselector, nc: *const ncinput) -> bool;
}
extern "C" {
    #[doc = " Destroy the ncmultiselector."]
    pub fn ncmultiselector_destroy(n: *mut ncmultiselector);
}
#[doc = " each item has a curry, and zero or more subitems."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct nctree_item {
    pub curry: *mut cty::c_void,
    pub subs: *mut nctree_item,
    pub subcount: cty::c_uint,
}
#[test]
fn bindgen_test_layout_nctree_item() {
    assert_eq!(
        ::core::mem::size_of::<nctree_item>(),
        24usize,
        concat!("Size of: ", stringify!(nctree_item))
    );
    assert_eq!(
        ::core::mem::align_of::<nctree_item>(),
        8usize,
        concat!("Alignment of ", stringify!(nctree_item))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nctree_item>())).curry as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nctree_item),
            "::",
            stringify!(curry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nctree_item>())).subs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nctree_item),
            "::",
            stringify!(subs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nctree_item>())).subcount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nctree_item),
            "::",
            stringify!(subcount)
        )
    );
}
impl Default for nctree_item {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct nctree_options {
    #[doc = " top-level nctree_item array"]
    pub items: *const nctree_item,
    #[doc = " size of |items|"]
    pub count: cty::c_uint,
    #[doc = " item callback function"]
    pub nctreecb: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ncplane,
            arg2: *mut cty::c_void,
            arg3: cty::c_int,
        ) -> cty::c_int,
    >,
    #[doc = " columns to indent per level of hierarchy"]
    pub indentcols: cty::c_int,
    #[doc = " bitfield of NCTREE_OPTION_*"]
    pub flags: u64,
}
#[test]
fn bindgen_test_layout_nctree_options() {
    assert_eq!(
        ::core::mem::size_of::<nctree_options>(),
        40usize,
        concat!("Size of: ", stringify!(nctree_options))
    );
    assert_eq!(
        ::core::mem::align_of::<nctree_options>(),
        8usize,
        concat!("Alignment of ", stringify!(nctree_options))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nctree_options>())).items as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nctree_options),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nctree_options>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nctree_options),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nctree_options>())).nctreecb as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nctree_options),
            "::",
            stringify!(nctreecb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nctree_options>())).indentcols as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nctree_options),
            "::",
            stringify!(indentcols)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nctree_options>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nctree_options),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for nctree_options {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nctree {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " |opts| may *not* be NULL, since it is necessary to define a callback"]
    #[doc = " function."]
    pub fn nctree_create(n: *mut ncplane, opts: *const nctree_options) -> *mut nctree;
}
extern "C" {
    #[doc = " Returns the ncplane on which this nctree lives."]
    pub fn nctree_plane(n: *mut nctree) -> *mut ncplane;
}
extern "C" {
    #[doc = " Redraw the nctree 'n' in its entirety. The tree will be cleared, and items"]
    #[doc = " will be lain out, using the focused item as a fulcrum. Item-drawing"]
    #[doc = " callbacks will be invoked for each visible item."]
    pub fn nctree_redraw(n: *mut nctree) -> cty::c_int;
}
extern "C" {
    #[doc = " Offer input 'ni' to the nctree 'n'. If it's relevant, this function returns"]
    #[doc = " true, and the input ought not be processed further. If it's irrelevant to"]
    #[doc = " the tree, false is returned. Relevant inputs include:"]
    #[doc = "  * a mouse click on an item (focuses item)"]
    #[doc = "  * a mouse scrollwheel event (srolls tree)"]
    #[doc = "  * up, down, pgup, or pgdown (navigates among items)"]
    pub fn nctree_offer_input(n: *mut nctree, ni: *const ncinput) -> bool;
}
extern "C" {
    #[doc = " Return the focused item, if any items are present. This is not a copy;"]
    #[doc = " be careful to use it only for the duration of a critical section."]
    pub fn nctree_focused(n: *mut nctree) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Change focus to the next item."]
    pub fn nctree_next(n: *mut nctree) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Change focus to the previous item."]
    pub fn nctree_prev(n: *mut nctree) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Go to the item specified by the array |spec|, terminated by UINT_MAX. If"]
    #[doc = " the spec is invalid, NULL is returned, and the depth of the first invalid"]
    #[doc = " spec is written to *|failspec|. Otherwise, the true depth is written to"]
    #[doc = " *|failspec|, and the curry is returned (|failspec| is necessary because the"]
    #[doc = " curry could itself be NULL)."]
    pub fn nctree_goto(
        n: *mut nctree,
        spec: *const cty::c_uint,
        failspec: *mut cty::c_int,
    ) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Destroy the nctree."]
    pub fn nctree_destroy(n: *mut nctree);
}
#[doc = " Menus. Horizontal menu bars are supported, on the top and/or bottom rows."]
#[doc = " If the menu bar is longer than the screen, it will be only partially"]
#[doc = " visible. Menus may be either visible or invisible by default. In the event of"]
#[doc = " a screen resize, menus will be automatically moved/resized. Elements can be"]
#[doc = " dynamically enabled or disabled at all levels (menu, section, and item),"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncmenu_item {
    #[doc = " utf-8 menu item, NULL for horizontal separator"]
    pub desc: *mut cty::c_char,
    #[doc = " shortcut, all should be distinct"]
    pub shortcut: ncinput,
}
#[test]
fn bindgen_test_layout_ncmenu_item() {
    assert_eq!(
        ::core::mem::size_of::<ncmenu_item>(),
        32usize,
        concat!("Size of: ", stringify!(ncmenu_item))
    );
    assert_eq!(
        ::core::mem::align_of::<ncmenu_item>(),
        8usize,
        concat!("Alignment of ", stringify!(ncmenu_item))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmenu_item>())).desc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmenu_item),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmenu_item>())).shortcut as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmenu_item),
            "::",
            stringify!(shortcut)
        )
    );
}
impl Default for ncmenu_item {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncmenu_section {
    #[doc = " utf-8 c string"]
    pub name: *mut cty::c_char,
    pub itemcount: cty::c_int,
    pub items: *mut ncmenu_item,
    #[doc = " shortcut, will be underlined if present in name"]
    pub shortcut: ncinput,
}
#[test]
fn bindgen_test_layout_ncmenu_section() {
    assert_eq!(
        ::core::mem::size_of::<ncmenu_section>(),
        48usize,
        concat!("Size of: ", stringify!(ncmenu_section))
    );
    assert_eq!(
        ::core::mem::align_of::<ncmenu_section>(),
        8usize,
        concat!("Alignment of ", stringify!(ncmenu_section))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmenu_section>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmenu_section),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmenu_section>())).itemcount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmenu_section),
            "::",
            stringify!(itemcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmenu_section>())).items as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmenu_section),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmenu_section>())).shortcut as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmenu_section),
            "::",
            stringify!(shortcut)
        )
    );
}
impl Default for ncmenu_section {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncmenu_options {
    #[doc = " array of 'sectioncount' menu_sections"]
    pub sections: *mut ncmenu_section,
    #[doc = " must be positive"]
    pub sectioncount: cty::c_int,
    #[doc = " styling for header"]
    pub headerchannels: u64,
    #[doc = " styling for sections"]
    pub sectionchannels: u64,
    #[doc = " flag word of NCMENU_OPTION_*"]
    pub flags: u64,
}
#[test]
fn bindgen_test_layout_ncmenu_options() {
    assert_eq!(
        ::core::mem::size_of::<ncmenu_options>(),
        40usize,
        concat!("Size of: ", stringify!(ncmenu_options))
    );
    assert_eq!(
        ::core::mem::align_of::<ncmenu_options>(),
        8usize,
        concat!("Alignment of ", stringify!(ncmenu_options))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmenu_options>())).sections as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmenu_options),
            "::",
            stringify!(sections)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmenu_options>())).sectioncount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmenu_options),
            "::",
            stringify!(sectioncount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmenu_options>())).headerchannels as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmenu_options),
            "::",
            stringify!(headerchannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmenu_options>())).sectionchannels as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmenu_options),
            "::",
            stringify!(sectionchannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncmenu_options>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ncmenu_options),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for ncmenu_options {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct ncmenu {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create a menu with the specified options. Menus are currently bound to an"]
    #[doc = " overall Notcurses object (as opposed to a particular plane), and are"]
    #[doc = " implemented as ncplanes kept atop other ncplanes."]
    pub fn ncmenu_create(n: *mut ncplane, opts: *const ncmenu_options) -> *mut ncmenu;
}
extern "C" {
    #[doc = " Unroll the specified menu section, making the menu visible if it was"]
    #[doc = " invisible, and rolling up any menu section that is already unrolled."]
    pub fn ncmenu_unroll(n: *mut ncmenu, sectionidx: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Roll up any unrolled menu section, and hide the menu if using hiding."]
    pub fn ncmenu_rollup(n: *mut ncmenu) -> cty::c_int;
}
extern "C" {
    #[doc = " Unroll the previous/next section (relative to current unrolled). If no"]
    #[doc = " section is unrolled, the first section will be unrolled."]
    pub fn ncmenu_nextsection(n: *mut ncmenu) -> cty::c_int;
}
extern "C" {
    pub fn ncmenu_prevsection(n: *mut ncmenu) -> cty::c_int;
}
extern "C" {
    #[doc = " Move to the previous/next item within the currently unrolled section. If no"]
    #[doc = " section is unrolled, the first section will be unrolled."]
    pub fn ncmenu_nextitem(n: *mut ncmenu) -> cty::c_int;
}
extern "C" {
    pub fn ncmenu_previtem(n: *mut ncmenu) -> cty::c_int;
}
extern "C" {
    #[doc = " Disable or enable a menu item. Returns 0 if the item was found."]
    pub fn ncmenu_item_set_status(
        n: *mut ncmenu,
        section: *const cty::c_char,
        item: *const cty::c_char,
        enabled: bool,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Return the selected item description, or NULL if no section is unrolled. If"]
    #[doc = " 'ni' is not NULL, and the selected item has a shortcut, 'ni' will be filled"]
    #[doc = " in with that shortcut--this can allow faster matching."]
    pub fn ncmenu_selected(n: *const ncmenu, ni: *mut ncinput) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Return the item description corresponding to the mouse click 'click'. The"]
    #[doc = " item must be on an actively unrolled section, and the click must be in the"]
    #[doc = " area of a valid item. If 'ni' is not NULL, and the selected item has a"]
    #[doc = " shortcut, 'ni' will be filled in with the shortcut."]
    pub fn ncmenu_mouse_selected(
        n: *const ncmenu,
        click: *const ncinput,
        ni: *mut ncinput,
    ) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Return the ncplane backing this ncmenu."]
    pub fn ncmenu_plane(n: *mut ncmenu) -> *mut ncplane;
}
extern "C" {
    #[doc = " Offer the input to the ncmenu. If it's relevant, this function returns true,"]
    #[doc = " and the input ought not be processed further. If it's irrelevant to the"]
    #[doc = " menu, false is returned. Relevant inputs include:"]
    #[doc = "  * mouse movement over a hidden menu"]
    #[doc = "  * a mouse click on a menu section (the section is unrolled)"]
    #[doc = "  * a mouse click outside of an unrolled menu (the menu is rolled up)"]
    #[doc = "  * left or right on an unrolled menu (navigates among sections)"]
    #[doc = "  * up or down on an unrolled menu (navigates among items)"]
    #[doc = "  * escape on an unrolled menu (the menu is rolled up)"]
    pub fn ncmenu_offer_input(n: *mut ncmenu, nc: *const ncinput) -> bool;
}
extern "C" {
    #[doc = " Destroy a menu created with ncmenu_create()."]
    pub fn ncmenu_destroy(n: *mut ncmenu) -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncprogbar_options {
    #[doc = " upper-left channel. in the context of a progress bar,"]
    pub ulchannel: u32,
    #[doc = " \"up\" is the direction we are progressing towards, and"]
    pub urchannel: u32,
    #[doc = " \"bottom\" is the direction of origin. for monochromatic"]
    pub blchannel: u32,
    #[doc = " bar, all four channels ought be the same."]
    pub brchannel: u32,
    pub flags: u64,
}
#[test]
fn bindgen_test_layout_ncprogbar_options() {
    assert_eq!(
        ::core::mem::size_of::<ncprogbar_options>(),
        24usize,
        concat!("Size of: ", stringify!(ncprogbar_options))
    );
    assert_eq!(
        ::core::mem::align_of::<ncprogbar_options>(),
        8usize,
        concat!("Alignment of ", stringify!(ncprogbar_options))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncprogbar_options>())).ulchannel as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncprogbar_options),
            "::",
            stringify!(ulchannel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncprogbar_options>())).urchannel as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ncprogbar_options),
            "::",
            stringify!(urchannel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncprogbar_options>())).blchannel as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncprogbar_options),
            "::",
            stringify!(blchannel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncprogbar_options>())).brchannel as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ncprogbar_options),
            "::",
            stringify!(brchannel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncprogbar_options>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncprogbar_options),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = " Takes ownership of the ncplane 'n', which will be destroyed by"]
    #[doc = " ncprogbar_destroy(). The progress bar is initially at 0%."]
    pub fn ncprogbar_create(n: *mut ncplane, opts: *const ncprogbar_options) -> *mut ncprogbar;
}
extern "C" {
    #[doc = " Return a reference to the ncprogbar's underlying ncplane."]
    pub fn ncprogbar_plane(n: *mut ncprogbar) -> *mut ncplane;
}
extern "C" {
    #[doc = " Set the progress bar's completion, a double 0 <= 'p' <= 1."]
    pub fn ncprogbar_set_progress(n: *mut ncprogbar, p: f64) -> cty::c_int;
}
extern "C" {
    #[doc = " Get the progress bar's completion, a double on [0, 1]."]
    pub fn ncprogbar_progress(n: *const ncprogbar) -> f64;
}
extern "C" {
    #[doc = " Destroy the progress bar and its underlying ncplane."]
    pub fn ncprogbar_destroy(n: *mut ncprogbar);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct nctabbed_options {
    #[doc = " channel for the selected tab header"]
    pub selchan: u64,
    #[doc = " channel for unselected tab headers"]
    pub hdrchan: u64,
    #[doc = " channel for the tab separator"]
    pub sepchan: u64,
    #[doc = " separator string (copied by nctabbed_create())"]
    pub separator: *mut cty::c_char,
    #[doc = " bitmask of NCTABBED_OPTION_*"]
    pub flags: u64,
}
#[test]
fn bindgen_test_layout_nctabbed_options() {
    assert_eq!(
        ::core::mem::size_of::<nctabbed_options>(),
        40usize,
        concat!("Size of: ", stringify!(nctabbed_options))
    );
    assert_eq!(
        ::core::mem::align_of::<nctabbed_options>(),
        8usize,
        concat!("Alignment of ", stringify!(nctabbed_options))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nctabbed_options>())).selchan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nctabbed_options),
            "::",
            stringify!(selchan)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nctabbed_options>())).hdrchan as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nctabbed_options),
            "::",
            stringify!(hdrchan)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nctabbed_options>())).sepchan as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nctabbed_options),
            "::",
            stringify!(sepchan)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nctabbed_options>())).separator as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nctabbed_options),
            "::",
            stringify!(separator)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nctabbed_options>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nctabbed_options),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for nctabbed_options {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Tab content drawing callback. Takes the tab it was associated to, the ncplane"]
#[doc = " on which tab content is to be drawn, and the user pointer of the tab."]
#[doc = " It is called during nctabbed_redraw()."]
pub type tabcb = ::core::option::Option<
    unsafe extern "C" fn(t: *mut nctab, ncp: *mut ncplane, curry: *mut cty::c_void),
>;
extern "C" {
    #[doc = " Creates a new nctabbed widget, associated with the given ncplane 'n', and with"]
    #[doc = " additional options given in 'opts'. When 'opts' is NULL, it acts as if it were"]
    #[doc = " called with an all-zero opts. The widget takes ownership of 'n', and destroys"]
    #[doc = " it when the widget is destroyed. Returns the newly created widget. Returns"]
    #[doc = " NULL on failure, also destroying 'n'."]
    pub fn nctabbed_create(n: *mut ncplane, opts: *const nctabbed_options) -> *mut nctabbed;
}
extern "C" {
    #[doc = " Destroy an nctabbed widget. All memory belonging to 'nt' is deallocated,"]
    #[doc = " including all tabs and their names. The plane associated with 'nt' is also"]
    #[doc = " destroyed. Calling this with NULL does nothing."]
    pub fn nctabbed_destroy(nt: *mut nctabbed);
}
extern "C" {
    #[doc = " Redraw the widget. This calls the tab callback of the currently selected tab"]
    #[doc = " to draw tab contents, and draws tab headers. The tab content plane is not"]
    #[doc = " modified by this function, apart from resizing the plane is necessary."]
    pub fn nctabbed_redraw(nt: *mut nctabbed);
}
extern "C" {
    #[doc = " Make sure the tab header of the currently selected tab is at least partially"]
    #[doc = " visible. (by rotating tabs until at least one column is displayed)"]
    #[doc = " Does nothing if there are no tabs."]
    pub fn nctabbed_ensure_selected_header_visible(nt: *mut nctabbed);
}
extern "C" {
    #[doc = " Returns the currently selected tab, or NULL if there are no tabs."]
    pub fn nctabbed_selected(nt: *mut nctabbed) -> *mut nctab;
}
extern "C" {
    #[doc = " Returns the leftmost tab, or NULL if there are no tabs."]
    pub fn nctabbed_leftmost(nt: *mut nctabbed) -> *mut nctab;
}
extern "C" {
    #[doc = " Returns the number of tabs in the widget."]
    pub fn nctabbed_tabcount(nt: *mut nctabbed) -> cty::c_int;
}
extern "C" {
    #[doc = " Returns the plane associated to 'nt'."]
    pub fn nctabbed_plane(nt: *mut nctabbed) -> *mut ncplane;
}
extern "C" {
    #[doc = " Returns the tab content plane."]
    pub fn nctabbed_content_plane(nt: *mut nctabbed) -> *mut ncplane;
}
extern "C" {
    #[doc = " Returns the tab callback."]
    pub fn nctab_cb(t: *mut nctab) -> tabcb;
}
extern "C" {
    #[doc = " Returns the tab name. This is not a copy and it should not be stored."]
    pub fn nctab_name(t: *mut nctab) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Returns the width (in columns) of the tab's name."]
    pub fn nctab_name_width(t: *mut nctab) -> cty::c_int;
}
extern "C" {
    #[doc = " Returns the tab's user pointer."]
    pub fn nctab_userptr(t: *mut nctab) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Returns the tab to the right of 't'. This does not change which tab is selected."]
    pub fn nctab_next(t: *mut nctab) -> *mut nctab;
}
extern "C" {
    #[doc = " Returns the tab to the left of 't'. This does not change which tab is selected."]
    pub fn nctab_prev(t: *mut nctab) -> *mut nctab;
}
extern "C" {
    #[doc = " Add a new tab to 'nt' with the given tab callback, name, and user pointer."]
    #[doc = " If both 'before' and 'after' are NULL, the tab is inserted after the selected"]
    #[doc = " tab. Otherwise, it gets put after 'after' (if not NULL) and before 'before'"]
    #[doc = " (if not NULL). If both 'after' and 'before' are given, they must be two"]
    #[doc = " neighboring tabs (the tab list is circular, so the last tab is immediately"]
    #[doc = " before the leftmost tab), otherwise the function returns NULL. If 'name' is"]
    #[doc = " NULL or a string containing illegal characters, the function returns NULL."]
    #[doc = " On all other failures the function also returns NULL. If it returns NULL,"]
    #[doc = " none of the arguments are modified, and the widget state is not altered."]
    pub fn nctabbed_add(
        nt: *mut nctabbed,
        after: *mut nctab,
        before: *mut nctab,
        tcb: tabcb,
        name: *const cty::c_char,
        opaque: *mut cty::c_void,
    ) -> *mut nctab;
}
extern "C" {
    #[doc = " Remove a tab 't' from 'nt'. Its neighboring tabs become neighbors to each"]
    #[doc = " other. If 't' if the selected tab, the tab after 't' becomes selected."]
    #[doc = " Likewise if 't' is the leftmost tab, the tab after 't' becomes leftmost."]
    #[doc = " If 't' is the only tab, there will no more be a selected or leftmost tab,"]
    #[doc = " until a new tab is added. Returns -1 if 't' is NULL, and 0 otherwise."]
    pub fn nctabbed_del(nt: *mut nctabbed, t: *mut nctab) -> cty::c_int;
}
extern "C" {
    #[doc = " Move 't' after 'after' (if not NULL) and before 'before' (if not NULL)."]
    #[doc = " If both 'after' and 'before' are NULL, the function returns -1, otherwise"]
    #[doc = " it returns 0."]
    pub fn nctab_move(
        nt: *mut nctabbed,
        t: *mut nctab,
        after: *mut nctab,
        before: *mut nctab,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Move 't' to the right by one tab, looping around to become leftmost if needed."]
    pub fn nctab_move_right(nt: *mut nctabbed, t: *mut nctab);
}
extern "C" {
    #[doc = " Move 't' to the right by one tab, looping around to become the last tab if needed."]
    pub fn nctab_move_left(nt: *mut nctabbed, t: *mut nctab);
}
extern "C" {
    #[doc = " Rotate the tabs of 'nt' right by 'amt' tabs, or '-amt' tabs left if 'amt' is"]
    #[doc = " negative. Tabs are rotated only by changing the leftmost tab; the selected tab"]
    #[doc = " stays the same. If there are no tabs, nothing happens."]
    pub fn nctabbed_rotate(nt: *mut nctabbed, amt: cty::c_int);
}
extern "C" {
    #[doc = " Select the tab after the currently selected tab, and return the newly selected"]
    #[doc = " tab. Returns NULL if there are no tabs."]
    pub fn nctabbed_next(nt: *mut nctabbed) -> *mut nctab;
}
extern "C" {
    #[doc = " Select the tab before the currently selected tab, and return the newly selected"]
    #[doc = " tab. Returns NULL if there are no tabs."]
    pub fn nctabbed_prev(nt: *mut nctabbed) -> *mut nctab;
}
extern "C" {
    #[doc = " Change the selected tab to be 't'. Returns the previously selected tab."]
    pub fn nctabbed_select(nt: *mut nctabbed, t: *mut nctab) -> *mut nctab;
}
extern "C" {
    #[doc = " Write the channels for tab headers, the selected tab header, and the separator"]
    #[doc = " to '*hdrchan', '*selchan', and '*sepchan' respectively."]
    pub fn nctabbed_channels(
        nt: *mut nctabbed,
        hdrchan: *mut u64,
        selchan: *mut u64,
        sepchan: *mut u64,
    );
}
extern "C" {
    #[doc = " Returns the tab separator. This is not a copy and it should not be stored."]
    #[doc = " This can be NULL, if the separator was set to NULL in ncatbbed_create() or"]
    #[doc = " nctabbed_set_separator()."]
    pub fn nctabbed_separator(nt: *mut nctabbed) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Returns the tab separator width, or zero if there is no separator."]
    pub fn nctabbed_separator_width(nt: *mut nctabbed) -> cty::c_int;
}
extern "C" {
    #[doc = " Set the tab headers channel for 'nt'."]
    pub fn nctabbed_set_hdrchan(nt: *mut nctabbed, chan: u64);
}
extern "C" {
    #[doc = " Set the selected tab header channel for 'nt'."]
    pub fn nctabbed_set_selchan(nt: *mut nctabbed, chan: u64);
}
extern "C" {
    #[doc = " Set the tab separator channel for 'nt'."]
    pub fn nctabbed_set_sepchan(nt: *mut nctabbed, chan: u64);
}
extern "C" {
    #[doc = " Set the tab callback function for 't'. Returns the previous tab callback."]
    pub fn nctab_set_cb(t: *mut nctab, newcb: tabcb) -> tabcb;
}
extern "C" {
    #[doc = " Change the name of 't'. Returns -1 if 'newname' is NULL, and 0 otherwise."]
    pub fn nctab_set_name(t: *mut nctab, newname: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    #[doc = " Set the user pointer of 't'. Returns the previous user pointer."]
    pub fn nctab_set_userptr(t: *mut nctab, newopaque: *mut cty::c_void) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Change the tab separator for 'nt'. Returns -1 if 'separator' is not NULL and"]
    #[doc = " is not a valid string, and 0 otherwise."]
    pub fn nctabbed_set_separator(nt: *mut nctabbed, separator: *const cty::c_char) -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncplot_options {
    #[doc = " channels for the maximum and minimum levels. linear or exponential"]
    #[doc = " interpolation will be applied across the domain between these two."]
    pub maxchannels: u64,
    pub minchannels: u64,
    #[doc = " styling used for the legend, if NCPLOT_OPTION_LABELTICKSD is set"]
    pub legendstyle: u16,
    #[doc = " number of \"pixels\" per row x column"]
    pub gridtype: ncblitter_e,
    #[doc = " independent variable can either be a contiguous range, or a finite set"]
    #[doc = " of keys. for a time range, say the previous hour sampled with second"]
    #[doc = " resolution, the independent variable would be the range [0..3600): 3600."]
    #[doc = " if rangex is 0, it is dynamically set to the number of columns."]
    pub rangex: cty::c_int,
    #[doc = " optional, printed by the labels"]
    pub title: *const cty::c_char,
    #[doc = " bitfield over NCPLOT_OPTION_*"]
    pub flags: u64,
}
#[test]
fn bindgen_test_layout_ncplot_options() {
    assert_eq!(
        ::core::mem::size_of::<ncplot_options>(),
        48usize,
        concat!("Size of: ", stringify!(ncplot_options))
    );
    assert_eq!(
        ::core::mem::align_of::<ncplot_options>(),
        8usize,
        concat!("Alignment of ", stringify!(ncplot_options))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplot_options>())).maxchannels as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplot_options),
            "::",
            stringify!(maxchannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplot_options>())).minchannels as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplot_options),
            "::",
            stringify!(minchannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplot_options>())).legendstyle as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplot_options),
            "::",
            stringify!(legendstyle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplot_options>())).gridtype as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplot_options),
            "::",
            stringify!(gridtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplot_options>())).rangex as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplot_options),
            "::",
            stringify!(rangex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplot_options>())).title as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplot_options),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncplot_options>())).flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ncplot_options),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for ncplot_options {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Use the provided plane 'n' for plotting according to the options 'opts'. The"]
    #[doc = " plot will make free use of the entirety of the plane. For domain"]
    #[doc = " autodiscovery, set miny == maxy == 0. ncuplot holds uint64_ts, while"]
    #[doc = " ncdplot holds doubles."]
    pub fn ncuplot_create(
        n: *mut ncplane,
        opts: *const ncplot_options,
        miny: u64,
        maxy: u64,
    ) -> *mut ncuplot;
}
extern "C" {
    pub fn ncdplot_create(
        n: *mut ncplane,
        opts: *const ncplot_options,
        miny: f64,
        maxy: f64,
    ) -> *mut ncdplot;
}
extern "C" {
    #[doc = " Return a reference to the ncplot's underlying ncplane."]
    pub fn ncuplot_plane(n: *mut ncuplot) -> *mut ncplane;
}
extern "C" {
    pub fn ncdplot_plane(n: *mut ncdplot) -> *mut ncplane;
}
extern "C" {
    #[doc = " Add to or set the value corresponding to this x. If x is beyond the current"]
    #[doc = " x window, the x window is advanced to include x, and values passing beyond"]
    #[doc = " the window are lost. The first call will place the initial window. The plot"]
    #[doc = " will be redrawn, but notcurses_render() is not called."]
    pub fn ncuplot_add_sample(n: *mut ncuplot, x: u64, y: u64) -> cty::c_int;
}
extern "C" {
    pub fn ncdplot_add_sample(n: *mut ncdplot, x: u64, y: f64) -> cty::c_int;
}
extern "C" {
    pub fn ncuplot_set_sample(n: *mut ncuplot, x: u64, y: u64) -> cty::c_int;
}
extern "C" {
    pub fn ncdplot_set_sample(n: *mut ncdplot, x: u64, y: f64) -> cty::c_int;
}
extern "C" {
    pub fn ncuplot_sample(n: *const ncuplot, x: u64, y: *mut u64) -> cty::c_int;
}
extern "C" {
    pub fn ncdplot_sample(n: *const ncdplot, x: u64, y: *mut f64) -> cty::c_int;
}
extern "C" {
    pub fn ncuplot_destroy(n: *mut ncuplot);
}
extern "C" {
    pub fn ncdplot_destroy(n: *mut ncdplot);
}
pub type ncfdplane_callback = ::core::option::Option<
    unsafe extern "C" fn(
        n: *mut ncfdplane,
        buf: *const cty::c_void,
        s: size_t,
        curry: *mut cty::c_void,
    ) -> cty::c_int,
>;
pub type ncfdplane_done_cb = ::core::option::Option<
    unsafe extern "C" fn(
        n: *mut ncfdplane,
        fderrno: cty::c_int,
        curry: *mut cty::c_void,
    ) -> cty::c_int,
>;
#[doc = " read from an fd until EOF (or beyond, if follow is set), invoking the user's"]
#[doc = " callback each time. runs in its own context. on EOF or error, the finalizer"]
#[doc = " callback will be invoked, and the user ought destroy the ncfdplane. the"]
#[doc = " data is *not* guaranteed to be nul-terminated, and may contain arbitrary"]
#[doc = " zeroes."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncfdplane_options {
    #[doc = " parameter provided to callbacks"]
    pub curry: *mut cty::c_void,
    #[doc = " keep reading after hitting end? (think tail -f)"]
    pub follow: bool,
    #[doc = " bitfield over NCOPTION_FDPLANE_*"]
    pub flags: u64,
}
#[test]
fn bindgen_test_layout_ncfdplane_options() {
    assert_eq!(
        ::core::mem::size_of::<ncfdplane_options>(),
        24usize,
        concat!("Size of: ", stringify!(ncfdplane_options))
    );
    assert_eq!(
        ::core::mem::align_of::<ncfdplane_options>(),
        8usize,
        concat!("Alignment of ", stringify!(ncfdplane_options))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncfdplane_options>())).curry as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncfdplane_options),
            "::",
            stringify!(curry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncfdplane_options>())).follow as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncfdplane_options),
            "::",
            stringify!(follow)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncfdplane_options>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncfdplane_options),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for ncfdplane_options {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Create an ncfdplane around the fd 'fd'. Consider this function to take"]
    #[doc = " ownership of the file descriptor, which will be closed in ncfdplane_destroy()."]
    pub fn ncfdplane_create(
        n: *mut ncplane,
        opts: *const ncfdplane_options,
        fd: cty::c_int,
        cbfxn: ncfdplane_callback,
        donecbfxn: ncfdplane_done_cb,
    ) -> *mut ncfdplane;
}
extern "C" {
    pub fn ncfdplane_plane(n: *mut ncfdplane) -> *mut ncplane;
}
extern "C" {
    pub fn ncfdplane_destroy(n: *mut ncfdplane) -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncsubproc_options {
    pub curry: *mut cty::c_void,
    #[doc = " restart this many seconds after an exit (watch)"]
    pub restart_period: u64,
    #[doc = " bitfield over NCOPTION_SUBPROC_*"]
    pub flags: u64,
}
#[test]
fn bindgen_test_layout_ncsubproc_options() {
    assert_eq!(
        ::core::mem::size_of::<ncsubproc_options>(),
        24usize,
        concat!("Size of: ", stringify!(ncsubproc_options))
    );
    assert_eq!(
        ::core::mem::align_of::<ncsubproc_options>(),
        8usize,
        concat!("Alignment of ", stringify!(ncsubproc_options))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncsubproc_options>())).curry as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncsubproc_options),
            "::",
            stringify!(curry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ncsubproc_options>())).restart_period as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncsubproc_options),
            "::",
            stringify!(restart_period)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncsubproc_options>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncsubproc_options),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for ncsubproc_options {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " see exec(2). p-types use $PATH. e-type passes environment vars."]
    pub fn ncsubproc_createv(
        n: *mut ncplane,
        opts: *const ncsubproc_options,
        bin: *const cty::c_char,
        arg: *const *mut cty::c_char,
        cbfxn: ncfdplane_callback,
        donecbfxn: ncfdplane_done_cb,
    ) -> *mut ncsubproc;
}
extern "C" {
    pub fn ncsubproc_createvp(
        n: *mut ncplane,
        opts: *const ncsubproc_options,
        bin: *const cty::c_char,
        arg: *const *mut cty::c_char,
        cbfxn: ncfdplane_callback,
        donecbfxn: ncfdplane_done_cb,
    ) -> *mut ncsubproc;
}
extern "C" {
    pub fn ncsubproc_createvpe(
        n: *mut ncplane,
        opts: *const ncsubproc_options,
        bin: *const cty::c_char,
        arg: *const *mut cty::c_char,
        env: *const *mut cty::c_char,
        cbfxn: ncfdplane_callback,
        donecbfxn: ncfdplane_done_cb,
    ) -> *mut ncsubproc;
}
extern "C" {
    pub fn ncsubproc_plane(n: *mut ncsubproc) -> *mut ncplane;
}
extern "C" {
    pub fn ncsubproc_destroy(n: *mut ncsubproc) -> cty::c_int;
}
extern "C" {
    #[doc = " Draw a QR code at the current position on the plane. If there is insufficient"]
    #[doc = " room to draw the code here, or there is any other error, non-zero will be"]
    #[doc = " returned. Otherwise, the QR code \"version\" (size) is returned. The QR code"]
    #[doc = " is (version * 4 + 17) columns wide, and ⌈version * 4 + 17⌉ rows tall (the"]
    #[doc = " properly-scaled values are written back to '*ymax' and '*xmax')."]
    pub fn ncplane_qrcode(
        n: *mut ncplane,
        ymax: *mut cty::c_int,
        xmax: *mut cty::c_int,
        data: *const cty::c_void,
        len: size_t,
    ) -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncreader_options {
    #[doc = " channels used for input"]
    pub tchannels: u64,
    #[doc = " attributes used for input"]
    pub tattrword: u32,
    #[doc = " bitfield of NCREADER_OPTION_*"]
    pub flags: u64,
}
#[test]
fn bindgen_test_layout_ncreader_options() {
    assert_eq!(
        ::core::mem::size_of::<ncreader_options>(),
        24usize,
        concat!("Size of: ", stringify!(ncreader_options))
    );
    assert_eq!(
        ::core::mem::align_of::<ncreader_options>(),
        8usize,
        concat!("Alignment of ", stringify!(ncreader_options))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncreader_options>())).tchannels as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncreader_options),
            "::",
            stringify!(tchannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncreader_options>())).tattrword as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncreader_options),
            "::",
            stringify!(tattrword)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncreader_options>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncreader_options),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = " ncreaders provide freeform input in a (possibly multiline) region, supporting"]
    #[doc = " optional readline keybindings. takes ownership of 'n', destroying it on any"]
    #[doc = " error (ncreader_destroy() otherwise destroys the ncplane)."]
    pub fn ncreader_create(n: *mut ncplane, opts: *const ncreader_options) -> *mut ncreader;
}
extern "C" {
    #[doc = " empty the ncreader of any user input, and home the cursor."]
    pub fn ncreader_clear(n: *mut ncreader) -> cty::c_int;
}
extern "C" {
    pub fn ncreader_plane(n: *mut ncreader) -> *mut ncplane;
}
extern "C" {
    #[doc = " Offer the input to the ncreader. If it's relevant, this function returns"]
    #[doc = " true, and the input ought not be processed further. Almost all inputs"]
    #[doc = " are relevant to an ncreader, save synthesized ones."]
    pub fn ncreader_offer_input(n: *mut ncreader, ni: *const ncinput) -> bool;
}
extern "C" {
    #[doc = " Atttempt to move in the specified direction. Returns 0 if a move was"]
    #[doc = " successfully executed, -1 otherwise. Scrolling is taken into account."]
    pub fn ncreader_move_left(n: *mut ncreader) -> cty::c_int;
}
extern "C" {
    pub fn ncreader_move_right(n: *mut ncreader) -> cty::c_int;
}
extern "C" {
    pub fn ncreader_move_up(n: *mut ncreader) -> cty::c_int;
}
extern "C" {
    pub fn ncreader_move_down(n: *mut ncreader) -> cty::c_int;
}
extern "C" {
    #[doc = " Destructively write the provided EGC to the current cursor location. Move"]
    #[doc = " the cursor as necessary, scrolling if applicable."]
    pub fn ncreader_write_egc(n: *mut ncreader, egc: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    #[doc = " return a heap-allocated copy of the current (UTF-8) contents."]
    pub fn ncreader_contents(n: *const ncreader) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " destroy the reader and its bound plane. if 'contents' is not NULL, the"]
    #[doc = " UTF-8 input will be heap-duplicated and written to 'contents'."]
    pub fn ncreader_destroy(n: *mut ncreader, contents: *mut *mut cty::c_char);
}
extern "C" {
    #[doc = " Dump selected Notcurses state to the supplied 'debugfp'. Output is freeform,"]
    #[doc = " newline-delimited, and subject to change. It includes geometry of all"]
    #[doc = " planes, from all piles. No line has more than 80 columns' worth of output."]
    pub fn notcurses_debug(nc: *const notcurses, debugfp: *mut FILE);
}
extern "C" {
    #[doc = " This function will be removed in ABI3 in favor of ncplane_create()."]
    #[doc = " It persists in ABI2 only for backwards compatibility."]
    pub fn ncplane_new(
        n: *mut ncplane,
        rows: cty::c_int,
        cols: cty::c_int,
        y: cty::c_int,
        x: cty::c_int,
        opaque: *mut cty::c_void,
        name: *const cty::c_char,
    ) -> *mut ncplane;
}
extern "C" {
    pub fn ncplane_styles_set(n: *mut ncplane, stylebits: cty::c_uint);
}
extern "C" {
    pub fn ncplane_styles_on(n: *mut ncplane, stylebits: cty::c_uint);
}
extern "C" {
    pub fn ncplane_styles_off(n: *mut ncplane, stylebits: cty::c_uint);
}
extern "C" {
    #[doc = " Deprecated form of nctablet_plane()."]
    pub fn nctablet_ncplane(t: *mut nctablet) -> *mut ncplane;
}
extern "C" {
    #[doc = " Inflate each pixel in the image to 'scale'x'scale' pixels. It is an error"]
    #[doc = " if 'scale' is less than 1. The original color is retained."]
    #[doc = " Deprecated; use ncvisual_resize_noninterpolative(), which this now wraps."]
    pub fn ncvisual_inflate(n: *mut ncvisual, scale: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn notcurses_render_to_buffer(
        nc: *mut notcurses,
        buf: *mut *mut cty::c_char,
        buflen: *mut size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn notcurses_render_to_file(nc: *mut notcurses, fp: *mut FILE) -> cty::c_int;
}
pub type cell = nccell;
extern "C" {
    pub fn notcurses_debug_caps(nc: *const notcurses, debugfp: *mut FILE);
}
#[repr(C)]
#[derive(Debug)]
pub struct ncdirect {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Initialize a direct-mode Notcurses context on the connected terminal at 'fp'."]
    #[doc = " 'fp' must be a tty. You'll usually want stdout. Direct mode supports a"]
    #[doc = " limited subset of Notcurses routines which directly affect 'fp', and neither"]
    #[doc = " supports nor requires notcurses_render(). This can be used to add color and"]
    #[doc = " styling to text in the standard output paradigm. 'flags' is a bitmask over"]
    #[doc = " NCDIRECT_OPTION_*."]
    #[doc = " Returns NULL on error, including any failure initializing terminfo."]
    pub fn ncdirect_init(termtype: *const cty::c_char, fp: *mut FILE, flags: u64) -> *mut ncdirect;
}
extern "C" {
    #[doc = " The same as ncdirect_init(), but without any multimedia functionality,"]
    #[doc = " allowing for a svelter binary. Link with notcurses-core if this is used."]
    pub fn ncdirect_core_init(
        termtype: *const cty::c_char,
        fp: *mut FILE,
        flags: u64,
    ) -> *mut ncdirect;
}
extern "C" {
    #[doc = " Read a (heap-allocated) line of text using the Readline library Initializes"]
    #[doc = " Readline the first time it's called. For input to be echoed to the terminal,"]
    #[doc = " it is necessary that NCDIRECT_OPTION_INHIBIT_CBREAK be provided to"]
    #[doc = " ncdirect_init(). Returns NULL on error."]
    pub fn ncdirect_readline(nc: *mut ncdirect, prompt: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " Direct mode. This API can be used to colorize and stylize output generated"]
    #[doc = " outside of notcurses, without ever calling notcurses_render(). These should"]
    #[doc = " not be intermixed with standard Notcurses rendering."]
    pub fn ncdirect_set_fg_rgb(nc: *mut ncdirect, rgb: cty::c_uint) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_set_bg_rgb(nc: *mut ncdirect, rgb: cty::c_uint) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_set_fg_palindex(nc: *mut ncdirect, pidx: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_set_bg_palindex(nc: *mut ncdirect, pidx: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Returns the number of simultaneous colors claimed to be supported, or 1 if"]
    #[doc = " there is no color support. Note that several terminal emulators advertise"]
    #[doc = " more colors than they actually support, downsampling internally."]
    pub fn ncdirect_palette_size(nc: *const ncdirect) -> cty::c_uint;
}
extern "C" {
    #[doc = " Output the string |utf8| according to the channels |channels|. Note that"]
    #[doc = " ncdirect_putstr() does not explicitly flush output buffers, so it will not"]
    #[doc = " necessarily be immediately visible."]
    pub fn ncdirect_putstr(
        nc: *mut ncdirect,
        channels: u64,
        utf8: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Formatted printing (plus alignment relative to the terminal). Returns the"]
    #[doc = " number of columns printed on success."]
    pub fn ncdirect_printf_aligned(
        n: *mut ncdirect,
        y: cty::c_int,
        align: ncalign_e,
        fmt: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Force a flush. Returns 0 on success, -1 on failure."]
    pub fn ncdirect_flush(nc: *const ncdirect) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_set_fg_default(nc: *mut ncdirect) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_set_bg_default(nc: *mut ncdirect) -> cty::c_int;
}
extern "C" {
    #[doc = " Get the current number of columns/rows."]
    pub fn ncdirect_dim_x(nc: *mut ncdirect) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_dim_y(nc: *mut ncdirect) -> cty::c_int;
}
extern "C" {
    #[doc = " Returns a 16-bit bitmask of supported curses-style attributes"]
    #[doc = " (NCSTYLE_UNDERLINE, NCSTYLE_BOLD, etc.) The attribute is only"]
    #[doc = " indicated as supported if the terminal can support it together with color."]
    #[doc = " For more information, see the \"ncv\" capability in terminfo(5)."]
    pub fn ncdirect_supported_styles(nc: *const ncdirect) -> cty::c_uint;
}
extern "C" {
    #[doc = " ncplane_styles_*() analogues"]
    pub fn ncdirect_set_styles(n: *mut ncdirect, stylebits: cty::c_uint) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_on_styles(n: *mut ncdirect, stylebits: cty::c_uint) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_off_styles(n: *mut ncdirect, stylebits: cty::c_uint) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_styles(n: *mut ncdirect) -> cty::c_uint;
}
extern "C" {
    #[doc = " Deprecated forms of above."]
    pub fn ncdirect_styles_set(n: *mut ncdirect, stylebits: cty::c_uint) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_styles_on(n: *mut ncdirect, stylebits: cty::c_uint) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_styles_off(n: *mut ncdirect, stylebits: cty::c_uint) -> cty::c_int;
}
extern "C" {
    #[doc = " Move the cursor in direct mode. -1 to retain current location on that axis."]
    pub fn ncdirect_cursor_move_yx(n: *mut ncdirect, y: cty::c_int, x: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_cursor_enable(nc: *mut ncdirect) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_cursor_disable(nc: *mut ncdirect) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_cursor_up(nc: *mut ncdirect, num: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_cursor_left(nc: *mut ncdirect, num: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_cursor_right(nc: *mut ncdirect, num: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_cursor_down(nc: *mut ncdirect, num: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " Get the cursor position, when supported. This requires writing to the"]
    #[doc = " terminal, and then reading from it. If the terminal doesn't reply, or"]
    #[doc = " doesn't reply in a way we understand, the results might be deleterious."]
    pub fn ncdirect_cursor_yx(
        n: *mut ncdirect,
        y: *mut cty::c_int,
        x: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Push or pop the cursor location to the terminal's stack. The depth of this"]
    #[doc = " stack, and indeed its existence, is terminal-dependent."]
    pub fn ncdirect_cursor_push(n: *mut ncdirect) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_cursor_pop(n: *mut ncdirect) -> cty::c_int;
}
extern "C" {
    #[doc = " Clear the screen."]
    pub fn ncdirect_clear(nc: *mut ncdirect) -> cty::c_int;
}
extern "C" {
    #[doc = " Capabilites"]
    pub fn ncdirect_detected_terminal(n: *const ncdirect) -> *const cty::c_char;
}
extern "C" {
    pub fn ncdirect_capabilities(n: *const ncdirect) -> *const nccapabilities;
}
extern "C" {
    #[doc = " Draw horizontal/vertical lines using the specified channels, interpolating"]
    #[doc = " between them as we go. The EGC may not use more than one column. For a"]
    #[doc = " horizontal line, |len| cannot exceed the screen width minus the cursor's"]
    #[doc = " offset. For a vertical line, it may be as long as you'd like; the screen"]
    #[doc = " will scroll as necessary. All lines start at the current cursor position."]
    pub fn ncdirect_hline_interp(
        n: *mut ncdirect,
        egc: *const cty::c_char,
        len: cty::c_int,
        h1: u64,
        h2: u64,
    ) -> cty::c_int;
}
extern "C" {
    pub fn ncdirect_vline_interp(
        n: *mut ncdirect,
        egc: *const cty::c_char,
        len: cty::c_int,
        h1: u64,
        h2: u64,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Draw a box with its upper-left corner at the current cursor position, having"]
    #[doc = " dimensions |ylen|x|xlen|. See ncplane_box() for more information. The"]
    #[doc = " minimum box size is 2x2, and it cannot be drawn off-screen. |wchars| is an"]
    #[doc = " array of 6 wide characters: UL, UR, LL, LR, HL, VL."]
    pub fn ncdirect_box(
        n: *mut ncdirect,
        ul: u64,
        ur: u64,
        ll: u64,
        lr: u64,
        wchars: *const wchar_t,
        ylen: cty::c_int,
        xlen: cty::c_int,
        ctlword: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " ncdirect_box() with the rounded box-drawing characters"]
    pub fn ncdirect_rounded_box(
        n: *mut ncdirect,
        ul: u64,
        ur: u64,
        ll: u64,
        lr: u64,
        ylen: cty::c_int,
        xlen: cty::c_int,
        ctlword: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " ncdirect_box() with the double box-drawing characters"]
    pub fn ncdirect_double_box(
        n: *mut ncdirect,
        ul: u64,
        ur: u64,
        ll: u64,
        lr: u64,
        ylen: cty::c_int,
        xlen: cty::c_int,
        ctlword: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " See ppoll(2) for more detail. Provide a NULL 'ts' to block at length, a 'ts'"]
    #[doc = " of 0 for non-blocking operation, and otherwise a timespec to bound blocking."]
    #[doc = " Signals in sigmask (less several we handle internally) will be atomically"]
    #[doc = " masked and unmasked per ppoll(2). '*sigmask' should generally contain all"]
    #[doc = " signals. Returns a single Unicode code point, or (char32_t)-1 on error."]
    #[doc = " 'sigmask' may be NULL. Returns 0 on a timeout. If an event is processed, the"]
    #[doc = " return value is the 'id' field from that event. 'ni' may be NULL."]
    pub fn ncdirect_getc(
        n: *mut ncdirect,
        ts: *const timespec,
        sigmask: *mut sigset_t,
        ni: *mut ncinput,
    ) -> char32_t;
}
extern "C" {
    #[doc = " Get a file descriptor suitable for input event poll()ing. When this"]
    #[doc = " descriptor becomes available, you can call ncdirect_getc_nblock(),"]
    #[doc = " and input ought be ready. This file descriptor is *not* necessarily"]
    #[doc = " the file descriptor associated with stdin (but it might be!)."]
    pub fn ncdirect_inputready_fd(n: *mut ncdirect) -> cty::c_int;
}
extern "C" {
    #[doc = " Release 'nc' and any associated resources. 0 on success, non-0 on failure."]
    pub fn ncdirect_stop(nc: *mut ncdirect) -> cty::c_int;
}
pub type ncdirectv = ncplane;
pub type ncdirectf = ncvisual;
#[doc = " FIXME this ought be used in the rendered mode API as well; it's currently"]
#[doc = " only used by direct mode. describes all geometries of an ncvisual--both those"]
#[doc = " which are inherent, and those in a given rendering regime. pixy and pixx are"]
#[doc = " the true internal pixel geometry, taken directly from the load (and updated"]
#[doc = " by ncvisual_resize()). cdimy/cdimx are the cell pixel geometry *at the time"]
#[doc = " of this call* (it can change with a font change, in which case all values"]
#[doc = " other than pixy/pixx are invalidated). rpixy/rpixx are the pixel geometry as"]
#[doc = " handed to the blitter, following any scaling. scaley/scalex are the number"]
#[doc = " of input pixels drawn to full cell; when using NCBLIT_PIXEL, they are"]
#[doc = " equivalent to cdimy/cdimx. rcelly/rcellx are the cell geometry as written by"]
#[doc = " the blitter, following any padding (there is padding whenever rpix{y, x} is"]
#[doc = " not evenly divided by scale{y, x}, and also sometimes for Sixel)."]
#[doc = " maxpixely/maxpixelx are defined only when NCBLIT_PIXEL is used, and specify"]
#[doc = " the largest bitmap that the terminal is willing to accept."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncvgeom {
    #[doc = " true pixel geometry of ncvisual data"]
    pub pixy: cty::c_int,
    #[doc = " true pixel geometry of ncvisual data"]
    pub pixx: cty::c_int,
    #[doc = " terminal cell geometry when this was calculated"]
    pub cdimy: cty::c_int,
    #[doc = " terminal cell geometry when this was calculated"]
    pub cdimx: cty::c_int,
    #[doc = " rendered pixel geometry"]
    pub rpixy: cty::c_int,
    #[doc = " rendered pixel geometry"]
    pub rpixx: cty::c_int,
    #[doc = " rendered cell geometry"]
    pub rcelly: cty::c_int,
    #[doc = " rendered cell geometry"]
    pub rcellx: cty::c_int,
    #[doc = " pixels per filled cell"]
    pub scaley: cty::c_int,
    #[doc = " pixels per filled cell"]
    pub scalex: cty::c_int,
    #[doc = " only defined for NCBLIT_PIXEL"]
    pub maxpixely: cty::c_int,
    #[doc = " only defined for NCBLIT_PIXEL"]
    pub maxpixelx: cty::c_int,
    #[doc = " blitter that will be used"]
    pub blitter: ncblitter_e,
}
#[test]
fn bindgen_test_layout_ncvgeom() {
    assert_eq!(
        ::core::mem::size_of::<ncvgeom>(),
        52usize,
        concat!("Size of: ", stringify!(ncvgeom))
    );
    assert_eq!(
        ::core::mem::align_of::<ncvgeom>(),
        4usize,
        concat!("Alignment of ", stringify!(ncvgeom))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvgeom>())).pixy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvgeom),
            "::",
            stringify!(pixy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvgeom>())).pixx as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvgeom),
            "::",
            stringify!(pixx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvgeom>())).cdimy as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvgeom),
            "::",
            stringify!(cdimy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvgeom>())).cdimx as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvgeom),
            "::",
            stringify!(cdimx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvgeom>())).rpixy as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvgeom),
            "::",
            stringify!(rpixy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvgeom>())).rpixx as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvgeom),
            "::",
            stringify!(rpixx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvgeom>())).rcelly as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvgeom),
            "::",
            stringify!(rcelly)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvgeom>())).rcellx as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvgeom),
            "::",
            stringify!(rcellx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvgeom>())).scaley as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvgeom),
            "::",
            stringify!(scaley)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvgeom>())).scalex as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvgeom),
            "::",
            stringify!(scalex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvgeom>())).maxpixely as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvgeom),
            "::",
            stringify!(maxpixely)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvgeom>())).maxpixelx as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvgeom),
            "::",
            stringify!(maxpixelx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ncvgeom>())).blitter as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvgeom),
            "::",
            stringify!(blitter)
        )
    );
}
impl Default for ncvgeom {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Display an image using the specified blitter and scaling. The image may"]
    #[doc = " be arbitrarily many rows -- the output will scroll -- but will only occupy"]
    #[doc = " the column of the cursor, and those to the right. The render/raster process"]
    #[doc = " can be split by using ncdirect_render_frame() and ncdirect_raster_frame()."]
    pub fn ncdirect_render_image(
        n: *mut ncdirect,
        filename: *const cty::c_char,
        align: ncalign_e,
        blitter: ncblitter_e,
        scale: ncscale_e,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Render an image using the specified blitter and scaling, but do not write"]
    #[doc = " the result. The image may be arbitrarily many rows -- the output will scroll"]
    #[doc = " -- but will only occupy the column of the cursor, and those to the right."]
    #[doc = " To actually write (and free) this, invoke ncdirect_raster_frame(). 'maxx'"]
    #[doc = " and 'maxy' (cell geometry, *not* pixel), if greater than 0, are used for"]
    #[doc = " scaling; the terminal's geometry is otherwise used."]
    pub fn ncdirect_render_frame(
        n: *mut ncdirect,
        filename: *const cty::c_char,
        blitter: ncblitter_e,
        scale: ncscale_e,
        maxy: cty::c_int,
        maxx: cty::c_int,
    ) -> *mut ncdirectv;
}
extern "C" {
    #[doc = " Takes the result of ncdirect_render_frame() and writes it to the output,"]
    #[doc = " freeing it on all paths."]
    pub fn ncdirect_raster_frame(
        n: *mut ncdirect,
        ncdv: *mut ncdirectv,
        align: ncalign_e,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Load media from disk, but do not yet render it (presumably because you want"]
    #[doc = " to get its geometry via ncdirectf_geom(), or to use the same file with"]
    #[doc = " ncdirect_render_loaded_frame() multiple times). You must destroy the result"]
    #[doc = " with ncdirectf_free();"]
    pub fn ncdirectf_from_file(n: *mut ncdirect, filename: *const cty::c_char) -> *mut ncdirectf;
}
extern "C" {
    #[doc = " Free a ncdirectf returned from ncdirectf_from_file()."]
    pub fn ncdirectf_free(frame: *mut ncdirectf);
}
extern "C" {
    #[doc = " Same as ncdirect_render_frame(), except 'frame' must already have been"]
    #[doc = " loaded. A loaded frame may be rendered in different ways before it is"]
    #[doc = " destroyed."]
    pub fn ncdirectf_render(
        n: *mut ncdirect,
        frame: *mut ncdirectf,
        vopts: *const ncvisual_options,
    ) -> *mut ncdirectv;
}
extern "C" {
    #[doc = " Having loaded the frame 'frame', get the geometry of a potential render."]
    pub fn ncdirectf_geom(
        n: *mut ncdirect,
        frame: *mut ncdirectf,
        vopts: *const ncvisual_options,
        geom: *mut ncvgeom,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Load successive frames from a file, invoking 'streamer' on each."]
    pub fn ncdirect_stream(
        n: *mut ncdirect,
        filename: *const cty::c_char,
        streamer: ncstreamcb,
        vopts: *mut ncvisual_options,
        curry: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Can we load images? This requires being built against FFmpeg/OIIO."]
    pub fn ncdirect_canopen_images(n: *const ncdirect) -> bool;
}
extern "C" {
    #[doc = " Is our encoding UTF-8? Requires LANG being set to a UTF8 locale."]
    pub fn ncdirect_canutf8(n: *const ncdirect) -> bool;
}
extern "C" {
    #[doc = " Can we blit pixel-accurate bitmaps?"]
    pub fn ncdirect_check_pixel_support(n: *const ncdirect) -> cty::c_int;
}
extern "C" {
    #[doc = " Is there support for acquiring the cursor's current position? Requires the"]
    #[doc = " u7 terminfo capability, and that we are connected to an actual terminal."]
    pub fn ncdirect_canget_cursor(nc: *const ncdirect) -> bool;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __va_list_tag {
    pub gp_offset: cty::c_uint,
    pub fp_offset: cty::c_uint,
    pub overflow_arg_area: *mut cty::c_void,
    pub reg_save_area: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::core::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
impl Default for __va_list_tag {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
